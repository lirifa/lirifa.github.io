<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>js中的闭包</title>
      <link href="/js%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85.html"/>
      <url>/js%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85.html</url>
      
        <content type="html"><![CDATA[<p>闭包是JavaScript中一个核心且强大的概念，理解闭包对于掌握JavaScript至关重要。</p><a id="more"></a><h1 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h1><p>闭包是指一个函数能够记住并访问其词法作用域，即使该函数在其词法作用域之外执行。</p><p>简单来说：当一个函数内部定义了另一个函数，并且内部函数引用了外部函数的变量，就形成了闭包。</p><h2 id="闭包的形成条件"><a href="#闭包的形成条件" class="headerlink" title="闭包的形成条件"></a>闭包的形成条件</h2><ul><li>函数嵌套（内部函数定义在外部函数内部）</li><li>内部函数引用外部函数的变量 </li><li>内部函数在外部函数之外被调用</li></ul><h2 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h2><ul><li>数据封装：创建私有变量，实现信息隐藏</li><li>状态保持：函数执行完后，变量仍然保存在内存中</li><li>模块化开发：创建独立的作用域，避免全局污染</li></ul><h2 id="常见应用场景"><a href="#常见应用场景" class="headerlink" title="常见应用场景"></a>常见应用场景</h2><ol><li>创建私有变量和方法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用闭包创建私有变量，只能通过特定方法访问。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createBankAccount</span>(<span class="params">initialBalance</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> balance = initialBalance;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        deposit: <span class="function"><span class="keyword">function</span>(<span class="params">amount</span>) </span>&#123;</span><br><span class="line">            balance += amount;</span><br><span class="line">        &#125;,</span><br><span class="line">        withdraw: <span class="function"><span class="keyword">function</span>(<span class="params">amount</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (amount &lt;= balance) &#123;</span><br><span class="line">                balance -= amount;</span><br><span class="line">                <span class="keyword">return</span> amount;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        getBalance: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> balance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>实现函数柯里化<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将多参数函数转换为一系列单参数函数。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> double = multiply(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> triple = multiply(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(double(<span class="number">5</span>)); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(triple(<span class="number">5</span>)); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure></li><li>模块模式开发<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建具有私有状态和公共接口的模块。</span></span><br><span class="line"><span class="keyword">const</span> myModule = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> privateVar = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> privateVar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        publicMethod: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> privateFunction();</span><br><span class="line">        &#125;,</span><br><span class="line">        increment: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            privateVar++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li><li>事件处理程序<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在事件处理函数中访问外部变量。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupButton</span>(<span class="params">buttonId, message</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> button = <span class="built_in">document</span>.getElementById(buttonId);</span><br><span class="line"></span><br><span class="line">    button.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(message); <span class="comment">// 闭包保留了message的引用</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>防抖和节流函数<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存定时器状态，实现性能优化。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeoutId; <span class="comment">// 闭包保存定时器ID</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeoutId);</span><br><span class="line">        timeoutId = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            func.apply(<span class="built_in">this</span>, args);</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>缓存函数（Memoization）<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">memoize</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 创建缓存键（使用JSON.stringify简化，生产环境建议更健壮的方案）</span></span><br><span class="line">        <span class="keyword">const</span> key = <span class="built_in">JSON</span>.stringify(args);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (cache.has(key)) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;从缓存返回结果&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span> cache.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;计算新结果&#x27;</span>);</span><br><span class="line">        <span class="keyword">const</span> result = fn.apply(<span class="built_in">this</span>, args);</span><br><span class="line">        cache.set(key, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例 - 缓存斐波那契计算</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用记忆化版本</span></span><br><span class="line"><span class="keyword">const</span> memoizedFibonacci = memoize(fibonacci);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(memoizedFibonacci(<span class="number">10</span>)); <span class="comment">// 第一次计算，输出&quot;计算新结果&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(memoizedFibonacci(<span class="number">10</span>)); <span class="comment">// 第二次相同参数，输出&quot;从缓存返回结果&quot;</span></span><br></pre></td></tr></table></figure></li><li>解决循环中的异步问题<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 问题代码</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i); <span class="comment">// 全部输出5</span></span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方案</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(j); <span class="comment">// 输出0,1,2,3,4</span></span><br><span class="line">        &#125;, <span class="number">100</span>);</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>内存管理：闭包会导致变量无法被垃圾回收，可能引起内存泄漏</li><li>性能考虑：过度使用闭包可能影响性能</li><li>正确使用：在不需要时及时解除引用</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>闭包是JavaScript中强大且灵活的特性，正确理解和使用闭包可以写出更加模块化、可维护性更高的代码。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js手写系列——节流函数、防抖函数</title>
      <link href="/js%E6%89%8B%E5%86%99%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E8%8A%82%E6%B5%81%E5%87%BD%E6%95%B0%E3%80%81%E9%98%B2%E6%8A%96%E5%87%BD%E6%95%B0.html"/>
      <url>/js%E6%89%8B%E5%86%99%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E8%8A%82%E6%B5%81%E5%87%BD%E6%95%B0%E3%80%81%E9%98%B2%E6%8A%96%E5%87%BD%E6%95%B0.html</url>
      
        <content type="html"><![CDATA[<p>节流（throttle）是一种常用的性能优化技术，用于限制函数在特定时间间隔内只能执行一次。当频繁触发某个事件时，节流可以确保函数不会过于频繁地执行，从而提升性能。<br>防抖（Debounce）是一种常用的性能优化技术，用于限制函数在短时间内被频繁调用。当事件被触发后，会等待一定时间间隔，如果在这段时间内事件没有被再次触发，才会执行函数。如果在这段时间内事件又被触发，则重新开始计时。</p><a id="more"></a><h1 id="节流函数"><a href="#节流函数" class="headerlink" title="节流函数"></a>节流函数</h1><h2 id="节流的基本概念"><a href="#节流的基本概念" class="headerlink" title="节流的基本概念"></a>节流的基本概念</h2><p>节流的核心思想是：<strong>在一定时间间隔内，无论事件触发多少次，函数只会执行一次。</strong></p><p>与防抖(debounce)不同，防抖是在事件停止触发后延迟执行，而节流是保证在固定时间间隔内至少执行一次。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>窗口大小调整(resize)事件</li><li>页面滚动(scroll)事件</li><li>鼠标移动(mousemove)事件</li><li>输入框实时搜索(减少请求频率)</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ol><li>基础时间戳版节流</li></ol><ul><li>使用时间戳判断是否达到执行间隔</li><li>第一次会立即执行</li><li>停止触发后不会再次执行<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttleBasic</span>(<span class="params">func, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> lastTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> currentTime = <span class="built_in">Date</span>.now();</span><br><span class="line">        <span class="keyword">if</span> (currentTime - lastTime &gt;= delay) &#123;</span><br><span class="line">            func.apply(<span class="built_in">this</span>, args);</span><br><span class="line">            lastTime = currentTime;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>定时器版节流</li></ol><ul><li>使用定时器延迟执行</li><li>第一次不会立即执行</li><li>停止触发后会再执行一次<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttleTimer</span>(<span class="params">func, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeoutId = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!timeoutId) &#123;</span><br><span class="line">            timeoutId = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                func.apply(<span class="built_in">this</span>, args);</span><br><span class="line">                timeoutId = <span class="literal">null</span>;</span><br><span class="line">            &#125;, delay);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>完整版节流（结合时间戳和定时器）</li></ol><ul><li>结合时间戳和定时器</li><li>可配置是否立即执行（leading）和停止后是否执行（trailing)</li><li>功能最完整，适用性最广<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, delay, options = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 函数签名和变量声明</span></span><br><span class="line">    <span class="comment">// func: 需要被节流的原始函数</span></span><br><span class="line">    <span class="comment">// delay: 节流时间间隔（毫秒）</span></span><br><span class="line">    <span class="comment">// options: 配置对象，包含 leading 和 trailing 选项</span></span><br><span class="line">    <span class="comment">// timeoutId: 存储定时器ID，用于取消定时器</span></span><br><span class="line">    <span class="comment">// lastTime: 记录上一次函数执行的时间戳</span></span><br><span class="line">    <span class="comment">// leading: 是否在节流开始时立即执行（默认true）</span></span><br><span class="line">    <span class="comment">// trailing: 是否在节流结束后执行（默认true）</span></span><br><span class="line">    <span class="keyword">let</span> timeoutId, lastTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> &#123; leading = <span class="literal">true</span>, trailing = <span class="literal">true</span> &#125; = options;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回的节流函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 保存原始函数的this上下文和参数</span></span><br><span class="line">        <span class="keyword">const</span> currentTime = <span class="built_in">Date</span>.now();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理leading=false的情况, 如果是第一次调用且leading为false，设置lastTime为当前时间, 这样第一次调用不会立即执行</span></span><br><span class="line">        <span class="keyword">if</span> (!lastTime &amp;&amp; !leading) lastTime = currentTime;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算距离下一次可以执行函数还剩余多少时间, currentTime - lastTime是距离上次执行经过的时间</span></span><br><span class="line">        <span class="keyword">const</span> remainingTime = delay - (currentTime - lastTime);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断是否需要立即执行</span></span><br><span class="line">        <span class="comment">// remainingTime &lt;= 0: 已经超过了节流间隔，可以立即执</span></span><br><span class="line">        <span class="comment">// remainingTime &gt; delay: 处理特殊情况（如系统时间被修改）</span></span><br><span class="line">        <span class="keyword">if</span> (remainingTime &lt;= <span class="number">0</span> || remainingTime &gt; delay) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timeoutId) &#123;</span><br><span class="line">                <span class="comment">// 清除可能存在的定时器</span></span><br><span class="line">                <span class="built_in">clearTimeout</span>(timeoutId);</span><br><span class="line">                timeoutId = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 立即执行原始函数</span></span><br><span class="line">            func.apply(<span class="built_in">this</span>, args);</span><br><span class="line">            <span class="comment">// 更新最后执行时间</span></span><br><span class="line">            lastTime = currentTime;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timeoutId &amp;&amp; trailing) &#123;</span><br><span class="line">            <span class="comment">//  设置延迟执行</span></span><br><span class="line">            <span class="comment">// !timeoutId: 确保不会重复设置定时器</span></span><br><span class="line">            <span class="comment">// trailing: 配置允许在节流结束后执行</span></span><br><span class="line">            timeoutId = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                func.apply(<span class="built_in">this</span>, args);</span><br><span class="line">                lastTime = <span class="built_in">Date</span>.now();</span><br><span class="line">                timeoutId = <span class="literal">null</span>;</span><br><span class="line">            &#125;, remainingTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h2><ul><li>对于需要立即响应的场景（如按钮点击），使用基础时间戳版</li><li>对于需要保证最后一次执行的场景，使用定时器版</li><li>大多数情况下，推荐使用完整版，因为它提供了最灵活的控制选项</li></ul><h1 id="防抖函数"><a href="#防抖函数" class="headerlink" title="防抖函数"></a>防抖函数</h1><h2 id="防抖的核心概念"><a href="#防抖的核心概念" class="headerlink" title="防抖的核心概念"></a>防抖的核心概念</h2><p>防抖的核心思想是：在事件被触发后，等待一定时间间隔，如果在这段时间内事件没有被再次触发，才会执行函数。如果在这段时间内事件再次被触发，则重新计时。</p><h2 id="防抖的工作原理"><a href="#防抖的工作原理" class="headerlink" title="防抖的工作原理"></a>防抖的工作原理</h2><ol><li>事件触发时，设置一个定时器</li><li>如果在定时器结束前事件再次触发，则清除之前的定时器并重新设置</li><li>只有当事件停止触发一段时间后，函数才会执行</li></ol><h2 id="防抖的应用场景"><a href="#防抖的应用场景" class="headerlink" title="防抖的应用场景"></a>防抖的应用场景</h2><ul><li>搜索框输入建议</li><li>窗口大小调整(resize)事件</li><li>表单验证</li><li>按钮点击防重复提交</li><li>自动保存功能</li></ul><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><ol><li>基础防抖函数<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounceBasic</span>(<span class="params">func, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeoutId;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 清除之前的定时器</span></span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeoutId);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置新的定时器</span></span><br><span class="line">        timeoutId = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            func.apply(<span class="built_in">this</span>, args);</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>立即执行版防抖函数<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounceImmediate</span>(<span class="params">func, delay, immediate = <span class="literal">false</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeoutId;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">const</span> callNow = immediate &amp;&amp; !timeoutId;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeoutId);</span><br><span class="line">        </span><br><span class="line">        timeoutId = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            timeoutId = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (!immediate) &#123;</span><br><span class="line">                func.apply(context, args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, delay);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (callNow) &#123;</span><br><span class="line">            func.apply(context, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>增强版防抖函数<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounceEnhanced</span>(<span class="params">func, delay, options = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeoutId;</span><br><span class="line">    <span class="keyword">let</span> lastExecTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> leading = options.leading || <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> trailing = options.trailing !== <span class="literal">false</span>; <span class="comment">// 默认true</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">const</span> currentTime = <span class="built_in">Date</span>.now();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 立即执行逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (leading &amp;&amp; !timeoutId) &#123;</span><br><span class="line">            func.apply(context, args);</span><br><span class="line">            lastExecTime = currentTime;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeoutId);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 延迟执行逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (trailing) &#123;</span><br><span class="line">            timeoutId = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                func.apply(context, args);</span><br><span class="line">                lastExecTime = <span class="built_in">Date</span>.now();</span><br><span class="line">                timeoutId = <span class="literal">null</span>;</span><br><span class="line">            &#125;, delay);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h2 id="防抖与节流的区别"><a href="#防抖与节流的区别" class="headerlink" title="防抖与节流的区别"></a>防抖与节流的区别</h2><table><thead><tr><th>特性</th><th>防抖(Debounce)</th><th>节流(Throttle)</th></tr></thead><tbody><tr><td>执行时机</td><td>在事件停止触发后执行</td><td>在固定时间间隔内执行</td></tr><tr><td>执行次数</td><td>只执行最后一次</td><td>至少执行一次</td></tr><tr><td>适用场景</td><td>搜索框输入、窗口调整</td><td>页面滚动、鼠标移动</td></tr></tbody></table><h1 id="涉及知识点"><a href="#涉及知识点" class="headerlink" title="涉及知识点"></a>涉及知识点</h1><ul><li><a href="https://lirifa.github.io/js%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85.html">闭包</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> js手写系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>免费cdn：jsdelivr+github 使用方法</title>
      <link href="/%E5%85%8D%E8%B4%B9cdn%EF%BC%9Ajsdelivr-github-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95.html"/>
      <url>/%E5%85%8D%E8%B4%B9cdn%EF%BC%9Ajsdelivr-github-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。</p><p align="right">——百度百科</p></blockquote><a id="more"></a><p>放在Github的资源在国内加载速度比较慢，因此需要使用CDN加速来优化网站打开速度，jsDelivr + Github便是免费且好用的CDN，非常适合博客网站使用。</p><h2 id="1-新建Github仓库"><a href="#1-新建Github仓库" class="headerlink" title="1.新建Github仓库"></a>1.新建Github仓库</h2><p><img src="https://cdn.jsdelivr.net/gh/lirifa/cdn/img/Snipaste_2021-01-08_15-06-41.png" alt="新建Github仓库"></p><h2 id="2-克隆Github仓库到本地"><a href="#2-克隆Github仓库到本地" class="headerlink" title="2.克隆Github仓库到本地"></a>2.克隆Github仓库到本地</h2><p><img src="https://cdn.jsdelivr.net/gh/lirifa/cdn/img/Snipaste_2021-01-08_15-07-28.png" alt="克隆Github仓库"></p><h2 id="3、上传资源"><a href="#3、上传资源" class="headerlink" title="3、上传资源"></a>3、上传资源</h2><p>复制需要上传的资源到本地git仓库（注：jsDelivr不支持加载超过20M的资源），在本地git仓库目录下右键 Git Bash Here，执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git status                    //查看状态</span><br><span class="line">git add .                     //添加所有文件到暂存区</span><br><span class="line">git commit -m &#x27;第一次提交&#x27;      //把文件提交到仓库</span><br><span class="line">git push                      //推送至远程仓库</span><br></pre></td></tr></table></figure><h2 id="4、发布仓库"><a href="#4、发布仓库" class="headerlink" title="4、发布仓库"></a>4、发布仓库</h2><p>点击发布<br><img src="https://cdn.jsdelivr.net/gh/lirifa/cdn@main/img/Snipaste_2021-01-08_15-30-30.png" alt="发布一个版本"></p><p><img src="https://cdn.jsdelivr.net/gh/lirifa/cdn@main/img/Snipaste_2021-01-08_15-59-42.png" alt="jsdelivr网站"></p><p>从jsdelivr官网发现我们可以有多种方式引用仓库文件<br>分别是</p><ul><li>release</li><li>commit</li><li>branch<br>大多数情况下，我们作为图床使用的话，用branch方式访问比较方便</li></ul><h2 id="5、通过jsDelivr引用资源"><a href="#5、通过jsDelivr引用资源" class="headerlink" title="5、通过jsDelivr引用资源"></a>5、通过jsDelivr引用资源</h2><p>使用方法：</p><ol><li><code>https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径</code></li><li><code>https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@commit/文件路径</code></li><li><code>https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@branch/文件路径</code></li></ol><p>例如</p><blockquote><p><a href="https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@1.0/images/trhx.png">https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@1.0/images/trhx.png</a><br>  <a href="https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@2.0.1/css/style.css">https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@2.0.1/css/style.css</a><br>  <a href="https://cdn.jsdelivr.net/gh/moezx/cdn@3.1.3//The%20Pet%20Girl%20of%20Sakurasou.mp4">https://cdn.jsdelivr.net/gh/moezx/cdn@3.1.3//The%20Pet%20Girl%20of%20Sakurasou.mp4</a></p></blockquote><p>注意：版本号不是必需的，是为了区分新旧资源，如果不使用版本号，将会直接引用最新资源，除此之外还可以使用某个范围内的版本，查看所有资源等，具体使用方法如下：</p><ul><li><p>// 加载任何Github发布、提交或分支<br><a href="https://cdn.jsdelivr.net/gh/user/repo@version/file">https://cdn.jsdelivr.net/gh/user/repo@version/file</a></p></li><li><p>// 加载 jQuery v3.2.1<br><a href="https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/dist/jquery.min.js">https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/dist/jquery.min.js</a></p></li><li><p>// 使用版本范围而不是特定版本<br><a href="https://cdn.jsdelivr.net/gh/jquery/jquery@3.2/dist/jquery.min.js">https://cdn.jsdelivr.net/gh/jquery/jquery@3.2/dist/jquery.min.js</a><br><a href="https://cdn.jsdelivr.net/gh/jquery/jquery@3/dist/jquery.min.js">https://cdn.jsdelivr.net/gh/jquery/jquery@3/dist/jquery.min.js</a></p></li><li><p>// 完全省略该版本以获取最新版本<br><a href="https://cdn.jsdelivr.net/gh/jquery/jquery/dist/jquery.min.js">https://cdn.jsdelivr.net/gh/jquery/jquery/dist/jquery.min.js</a><br><a href="https://cdn.jsdelivr.net/gh/jquery/jquery@latest/dist/jquery.min.js">https://cdn.jsdelivr.net/gh/jquery/jquery@latest/dist/jquery.min.js</a></p></li><li><p>// 将“.min”添加到任何JS/CSS文件中以获取缩小版本，如果不存在，将为会自动生成<br><a href="https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/src/core.min.js">https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/src/core.min.js</a></p></li><li><p>// 在末尾添加 / 以获取资源目录列表<br><a href="https://cdn.jsdelivr.net/gh/jquery/jquery/">https://cdn.jsdelivr.net/gh/jquery/jquery/</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>H5 video开发问题及相关知识点</title>
      <link href="/H5-video%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E5%8F%8A%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9.html"/>
      <url>/H5-video%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E5%8F%8A%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9.html</url>
      
        <content type="html"><![CDATA[<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>video 标签最基本的使用是，指定src并加上controls属性，这样在支持的浏览器上便可以播放了。如果浏览器不支持video标签则会显示标签中的提示文字</p><a id="more"></a><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">&quot;http://clips.vorwaerts-gmbh.de/big_buck_bunny.mp4&quot;</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">    当前浏览器不支持video标签</span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>提示文字可以再放在其他标签中，如再套个p标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">&quot;http://clips.vorwaerts-gmbh.de/big_buck_bunny.mp4&quot;</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span> 当前浏览器不支持video标签 <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="使用source标签"><a href="#使用source标签" class="headerlink" title="使用source标签"></a>使用source标签</h2><p>source标签可以为同一video元素指定不同的视频格式（来源），让浏览器自行选择自己支持的格式播放，不支持的视频源会被忽略</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;some-video.mp4&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/mp4&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;some-video.ogg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/ogg&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span> 当前浏览器不支持video标签 <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="配置多个属性，满足需求"><a href="#配置多个属性，满足需求" class="headerlink" title="配置多个属性，满足需求"></a>配置多个属性，满足需求</h2><p>给video标签设置属性，以满足一定的需求，如loop进行循环播放，width指定video的宽度<br><a href="https://www.w3school.com.cn/tags/tag_video.asp">属性详情</a></p><table><thead><tr><th align="left">属性</th><th align="left">值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">autoplay</td><td align="left">autoplay</td><td align="left">如果出现该属性，则视频在就绪后马上播放。</td></tr><tr><td align="left">controls</td><td align="left">controls</td><td align="left">如果出现该属性，则向用户显示控件，比如播放按钮。</td></tr><tr><td align="left">width</td><td align="left">pixels</td><td align="left">设置视频播放器的宽度。</td></tr><tr><td align="left">height</td><td align="left">pixels</td><td align="left">设置视频播放器的高度。</td></tr><tr><td align="left">loop</td><td align="left">loop</td><td align="left">如果出现该属性，则当媒介文件完成播放后再次开始播放。</td></tr><tr><td align="left">muted</td><td align="left">muted</td><td align="left">规定视频的音频输出应该被静音。</td></tr><tr><td align="left">poster</td><td align="left">URL</td><td align="left">规定视频下载时显示的图像，或者在用户点击播放按钮前显示的图像。</td></tr><tr><td align="left">preload</td><td align="left">preload</td><td align="left">如果出现该属性，则视频在页面加载时进行加载，并预备播放。如果使用 “autoplay”，则忽略该属性。</td></tr><tr><td align="left">src</td><td align="left">url</td><td align="left">要播放的视频的 URL。</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span></span></span><br><span class="line"><span class="tag">    <span class="attr">controls</span></span></span><br><span class="line"><span class="tag">    <span class="attr">loop</span></span></span><br><span class="line"><span class="tag">    <span class="attr">width</span>=<span class="string">&quot;400&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">src</span>=<span class="string">&quot;http://clips.vorwaerts-gmbh.de/big_buck_bunny.mp4&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span>&gt;</span>当前浏览器不支持video标签<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="video点播与直播"><a href="#video点播与直播" class="headerlink" title="video点播与直播"></a>video点播与直播</h2><p> H5 video目前所有浏览器都支持的视频格式是MP4格式，所以mp4应当是点播web视频的首选格式。<br>而在直播视频上，H5 video只在移动端原生支持HLS流的直播视频(Mac safari video标签也支持， PC Chrome不支持)，其他直播流（如FLV）就需要Flash插件的支持。</p><h2 id="video与206状态码"><a href="#video与206状态码" class="headerlink" title="video与206状态码"></a>video与206状态码</h2><p>video播放mp4时，发的依然是get请求，但http返回206状态码， 即partial Content。有关206状态码的相关内容，可以参考下文</p><ul><li><a href="http://blog.aijc.net/server/2015/11/12/HTTP%E5%8D%8F%E8%AE%AE206%E7%8A%B6%E6%80%81%E7%A0%81">Http协议206状态码</a></li></ul><h2 id="终止视频下载"><a href="#终止视频下载" class="headerlink" title="终止视频下载"></a>终止视频下载</h2><p>video.pause() 可以暂停视频播放，但并不能停止视频资源的继续加载，媒体元素会继续加载知道被垃圾回收机制回收。<br>要在暂停播放后立即停止，可使用以下方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">video.pause()</span><br><span class="line">video.src=<span class="string">&#x27;&#x27;</span></span><br><span class="line">video.removeAttribute(<span class="string">&#x27;src&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="切换src地址后重新加载播放"><a href="#切换src地址后重新加载播放" class="headerlink" title="切换src地址后重新加载播放"></a>切换src地址后重新加载播放</h2><p>修改video src 地址后，视频并不会重新的地址加载视频，重新加载可以使用以下方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">video.src=<span class="string">&#x27;新视频地址&#x27;</span></span><br><span class="line">video.load()</span><br><span class="line">video.play()</span><br></pre></td></tr></table></figure><h2 id="防止iOS上默认全屏播放"><a href="#防止iOS上默认全屏播放" class="headerlink" title="防止iOS上默认全屏播放"></a>防止iOS上默认全屏播放</h2><p>ios10及以后的版本，可以通过给video标签加playsinline属性防止iOS默认全屏播放，ios9之前加webkit-playsinline属性，如果要兼容，则把两个属性都加上。</p><p>通过客户端添加配置UIwebview: webview.allowsInlineMediaPlayback = YES，不过还是要求在video元素上加playsinline属性<br>参考</p><ul><li><a href="https://stackoverflow.com/questions/3699552/html5-inline-video-on-iphone-vs-ipad-browser">HTML5 inline video on iPhone vs iPad/Browser</a></li><li><a href="https://developer.apple.com/documentation/uikit/uiwebview/1617960-allowsinlinemediaplayback">allowsInlineMediaPlayback</a></li></ul><h2 id="自动播放及播放控制"><a href="#自动播放及播放控制" class="headerlink" title="自动播放及播放控制"></a>自动播放及播放控制</h2><p>在移动端，有些浏览器支持添加autoplay属性后自动播放，有些设置 autoplay 和 muted属性也能自动播放，比如IOS 10+、Chrome。</p><p>如果想控制什么时候播放，且并不是用户触发的（如没有设置controls），那就设置muted属性，然后调用video.play()方法，隔300ms左右有后，再通过video.muted = false打开声音。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vide.muted = <span class="literal">true</span>;</span><br><span class="line">video.play()</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    video.muted = <span class="literal">false</span></span><br><span class="line">&#125;, <span class="number">300</span>)</span><br></pre></td></tr></table></figure><p>iOS9及之前的版本要求有用户交互才能播放，即手动点击播放按钮或者有用户触发的click、touchend、键盘等事件，然后调用video.play() 方法播放。在iOS9之前，iOS Native可以通过UIWebView的mediaPlaybackRequiresUserAction属性来控制是否需要用户交互。</p><p>使用element.click()触发的click事件是否可以被人为是用户行为？不能<br>浏览器是如何知道是否是用户触发的事件？Event对象的只读属性isTrusted</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test-ele&quot;</span>&gt;</span>这个元素监听事件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> testEle = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#test-ele&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    testEle.addEventlistener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">evt</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 用户触发为true，script或EventTarget.dispatchEvent() 触发为false</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(evt.isTrusted);</span></span><br><span class="line"><span class="javascript">    &#125;, <span class="literal">false</span>);</span></span><br><span class="line"><span class="javascript">    testEle.click() <span class="comment">// 这个触发，evt.isTrusted = false</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>有关iOS 10对safari video的放松策略可以参考: <a href="https://webkit.org/blog/6784/new-video-policies-for-ios/">New <video> Policies for iOS</a></p><h2 id="video-play-的Promise对象（可用于捕获视频播放错误）"><a href="#video-play-的Promise对象（可用于捕获视频播放错误）" class="headerlink" title="video.play() 的Promise对象（可用于捕获视频播放错误）"></a>video.play() 的Promise对象（可用于捕获视频播放错误）</h2><p>在Chrome上，如果没有设置video.muted属性，在非用户行为下，直接使用video.play() 播放，会收到 Uncaught (in promise) DOMException 的报错，视频也没有播放。在iOS下面，可能不会有任何报错，视频也没播放，这样就无法定位问题。</p><p>video.play() 会返回一个Promise对象，如果播放失败，可以通过返回的Promise catch到相关错误信息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pro = video.play();</span><br><span class="line"><span class="keyword">if</span> (pro) &#123;  <span class="comment">// iOS9及以下版本不会返回Promise对象，做下兼容处理</span></span><br><span class="line">   pro.catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123; <span class="built_in">console</span>.log(err) &#125;);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TimeRanges-对象"><a href="#TimeRanges-对象" class="headerlink" title="TimeRanges 对象"></a>TimeRanges 对象</h2><p>在开始获取played属性的时候，以为会返回一个已经播放的时长，实际上返回的是TimeRanges对象，而且看到TimeRanges的length一直不变，当时一脸摸不着头脑，不知道有什么用。后来在做进度控制，需要知道视频已缓冲多少时，才弄明白。</p><p>video DOM对象有三个属性会返回TimeRanges对象，分别为video.played/ video.buffered/ video.seekable</p><p>视频开始时只有一个播放时间段，如果不进行跳跃观看，就一直只有一个时间段，即 TimeRanges.length 值为1；如果进行了跳跃观看（如从2分钟，突然跳进到15分钟的位置），而跳跃内容并没有缓冲完毕，则会出现两个时间段，这时TimeRanges的length为2。所以TimeRanges个数会随着跳跃观看未缓冲完成的内容而增加，随着缓冲的完成而减少，最少为1个，即从开头到结尾。</p><hr><h2 id=""><a href="#" class="headerlink" title="|==========|  |===========| |"></a>|==========|  |===========| |</h2><p>0         5        15  19       21</p><p>TimeRanges对象有一个length属性和start()、play()两个方法：TimeRanges:<br>    length: 1      // 代表当前播放视频存在的播放段<br>    play(index)    // 获取指定播放段的播放（缓冲）开始时间，index从0开始取，以秒计<br>    end(index)     // 获取指定播放段的播放（缓冲）结束时间<br>要获取第一段的开始时间，使用TimeRanges.start(0)，结束时间为TimeRanges.end(0)，第二段TimeRanges.start(1)，以此类推<br>参考</p><ul><li>Media buffering, seeking, and time ranges: (<a href="https://developer.mozilla.org/en-US/docs/Web/Guide/Audio_and_video_delivery/buffering_seeking_time_ranges">https://developer.mozilla.org/en-US/docs/Web/Guide/Audio_and_video_delivery/buffering_seeking_time_ranges</a>)</li><li>Time​Ranges: (<a href="https://developer.mozilla.org/en-US/docs/Web/API/TimeRanges">https://developer.mozilla.org/en-US/docs/Web/API/TimeRanges</a>)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DOM事件流</title>
      <link href="/DOM%E4%BA%8B%E4%BB%B6%E6%B5%81.html"/>
      <url>/DOM%E4%BA%8B%E4%BB%B6%E6%B5%81.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是DOM事件流"><a href="#1-什么是DOM事件流" class="headerlink" title="1.什么是DOM事件流"></a>1.什么是DOM事件流</h2><p>话不多说，先附上W3C链接：<a href="https://www.w3.org/TR/DOM-Level-3-Events/#event-flow">https://www.w3.org/TR/DOM-Level-3-Events/#event-flow</a><br><img src="https://s3.ax1x.com/2020/11/20/DQyEwV.png" alt="www.w3.org/TR/DOM-Leve…"><br>上图是W3C标准的DOM事件流模型图，从图中可以看出，元素事件响应在DOM树中是从顶层的Window开始“流向”目标元素（），然后又从目标元素“流向”顶层的Window。</p><p>通常，我们将这种事件流向分为三个阶段：<strong>捕获阶段</strong>，<strong>目标阶段</strong>，<strong>冒泡阶段</strong>。</p><ul><li>捕获阶段是指事件响应从最外层的Window开始，逐级向内层前进，直到具体事件目标元素。在捕获阶段，不会处理响应元素注册的冒泡事件。</li><li> 目标阶段指触发事件的最底层的元素，如上图中的。</li><li> 冒泡阶段与捕获阶段相反，事件的响应是从最底层开始一层一层往外传递到最外层的Window。</li></ul><p>现在，我们就可以知道，DOM事件流的三个阶段是先捕获阶段，然后是目标阶段，最后才是冒泡阶段。我们时常面试所说的先捕获后冒泡也由此而来。事件代理就是利用事件冒泡或事件捕获的机制把一系列的内层元素事件绑定到外层元素。</p><h2 id="2-事件冒泡和事件捕获"><a href="#2-事件冒泡和事件捕获" class="headerlink" title="2.事件冒泡和事件捕获"></a>2.事件冒泡和事件捕获</h2><p>实际操作中，我们可以通过 element.addEventListener() 设置一个元素的事件模型为冒泡事件或者捕获事件。</p><p>先来看一下 addEventListener 函数的语法： </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.addEventListener(type, listener, useCapture)</span><br></pre></td></tr></table></figure><ul><li>type<br>监听事件类型的字符串  </li><li>listener<br>事件监听回调函数，即事件触发后要处理的函数  </li><li>useCapture<br>默认值false，表示事件冒泡；设为true时，表示事件捕获</li></ul><h2 id="3-事件冒泡举例"><a href="#3-事件冒泡举例" class="headerlink" title="3.事件冒泡举例"></a>3.事件冒泡举例</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;a&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 300px; height: 300px;background-color: red;&quot;</span>&gt;</span></span><br><span class="line">    a</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;b&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 200px; height: 200px;background-color: yellow;&quot;</span>&gt;</span></span><br><span class="line">        b</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;c&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 100px; height: 100px;background-color: #2b9ab4;&quot;</span>&gt;</span></span><br><span class="line">            c</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> a = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;a&#x27;</span>)</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> b = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;b&#x27;</span>)</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> c = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;c&#x27;</span>)</span></span><br><span class="line"><span class="javascript"><span class="comment">//注册冒泡事件监听器</span></span></span><br><span class="line"><span class="javascript">a.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&quot;捕获a&quot;</span>)&#125;)</span></span><br><span class="line"><span class="javascript">b.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&#x27;捕获b&#x27;</span>)&#125;)</span></span><br><span class="line"><span class="javascript">c.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&quot;捕获c&quot;</span>)&#125;)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当我们点击c时，执行结果如下：</p><p><img src="https://s3.ax1x.com/2020/11/20/DQglOs.png" alt="执行结果"></p><p>冒泡事件的执行顺序为：c -&gt; b -&gt; a</p><h2 id="4-事件捕获举例"><a href="#4-事件捕获举例" class="headerlink" title="4.事件捕获举例"></a>4.事件捕获举例</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;a&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 300px; height: 300px;background-color: red;&quot;</span>&gt;</span></span><br><span class="line">    a</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;b&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 200px; height: 200px;background-color: yellow;&quot;</span>&gt;</span></span><br><span class="line">        b</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;c&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 100px; height: 100px;background-color: #2b9ab4;&quot;</span>&gt;</span></span><br><span class="line">            c</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> a = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;a&#x27;</span>)</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> b = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;b&#x27;</span>)</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> c = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;c&#x27;</span>)</span></span><br><span class="line"><span class="javascript"><span class="comment">//注册捕获事件监听器</span></span></span><br><span class="line"><span class="javascript">a.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&quot;捕获a&quot;</span>)&#125;, <span class="literal">true</span>)</span></span><br><span class="line"><span class="javascript">b.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&#x27;捕获b&#x27;</span>)&#125;, <span class="literal">true</span>)</span></span><br><span class="line"><span class="javascript">c.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&quot;捕获c&quot;</span>)&#125;, <span class="literal">true</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当我们点击c时，运行结果如下：<br><img src="https://s3.ax1x.com/2020/11/20/DQgI0I.png" alt="执行结果"><br>捕获事件的执行顺序为：a -&gt; b -&gt; c</p><h2 id="5-事件捕获VS事件冒泡"><a href="#5-事件捕获VS事件冒泡" class="headerlink" title="5.事件捕获VS事件冒泡"></a>5.事件捕获VS事件冒泡</h2><p>我们将上述的代码a,b,c三个元素都注册捕获和冒泡事件，并以元素c作为触发事件的主体，即事件流中的目标阶段。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;a&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 300px; height: 300px;background-color: red;&quot;</span>&gt;</span></span><br><span class="line">    a</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;b&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 200px; height: 200px;background-color: yellow;&quot;</span>&gt;</span></span><br><span class="line">        b</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;c&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 100px; height: 100px;background-color: #2b9ab4;&quot;</span>&gt;</span></span><br><span class="line">            c</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> a = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;a&#x27;</span>)</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> b = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;b&#x27;</span>)</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> c = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;c&#x27;</span>)</span></span><br><span class="line"><span class="javascript"><span class="comment">//注册冒泡事件监听器</span></span></span><br><span class="line"><span class="javascript">a.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&quot;冒泡a&quot;</span>)&#125;)</span></span><br><span class="line"><span class="javascript">b.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&#x27;冒泡b&#x27;</span>)&#125;)</span></span><br><span class="line"><span class="javascript">c.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&quot;冒泡c&quot;</span>)&#125;)</span></span><br><span class="line"><span class="javascript"><span class="comment">//注册捕获事件监听器</span></span></span><br><span class="line"><span class="javascript">a.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&quot;捕获a&quot;</span>)&#125;, <span class="literal">true</span>)</span></span><br><span class="line"><span class="javascript">b.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&#x27;捕获b&#x27;</span>)&#125;, <span class="literal">true</span>)</span></span><br><span class="line"><span class="javascript">c.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&quot;捕获c&quot;</span>)&#125;, <span class="literal">true</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>a,b,c三个元素都是先注册冒泡事件再注册捕获事件，当我们点击c时，执行结果又是如何？请看下图。<br><img src="https://s3.ax1x.com/2020/11/20/DQ2yuj.png" alt="执行结果"><br>从执行结果可以看到，a,b两个元素的事件响应都是先捕获后冒泡的，但对于触发事件的目标元素c，事件的响应并没有遵循先捕获后冒泡的规则</p><p>这是为什么？</p><p>因为<strong>目标元素是事件触发主体处于事件流中的目标阶段，处理事件的顺序是根据注册顺序来执行的。</strong></p><p>我们将上图中c元素的事件注册调换一下顺序</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;a&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 300px; height: 300px;background-color: red;&quot;</span>&gt;</span></span><br><span class="line">    a</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;b&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 200px; height: 200px;background-color: yellow;&quot;</span>&gt;</span></span><br><span class="line">        b</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;c&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 100px; height: 100px;background-color: #2b9ab4;&quot;</span>&gt;</span></span><br><span class="line">            c</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> a = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;a&#x27;</span>)</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> b = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;b&#x27;</span>)</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> c = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;c&#x27;</span>)</span></span><br><span class="line"><span class="javascript"><span class="comment">//注册冒泡事件监听器</span></span></span><br><span class="line"><span class="javascript">a.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&quot;冒泡a&quot;</span>)&#125;)</span></span><br><span class="line"><span class="javascript">b.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&#x27;冒泡b&#x27;</span>)&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="comment">// 事件注册调换顺序</span></span></span><br><span class="line"><span class="javascript">c.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&quot;捕获c&quot;</span>)&#125;, <span class="literal">true</span>)</span></span><br><span class="line"><span class="javascript">c.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&quot;冒泡c&quot;</span>)&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="comment">//注册捕获事件监听器</span></span></span><br><span class="line"><span class="javascript">a.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&quot;捕获a&quot;</span>)&#125;, <span class="literal">true</span>)</span></span><br><span class="line"><span class="javascript">b.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&#x27;捕获b&#x27;</span>)&#125;, <span class="literal">true</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>执行结果：<br><img src="https://s3.ax1x.com/2020/11/20/DQR1I0.png" alt="执行结果"><br>对于非目标元素，如果我们要先执行冒泡事件再执行捕获事件，我们可以在注册监听器时通过暂缓执行捕获事件，等冒泡事件执行完之后，在执行捕获事件。</p><h2 id="6-事件代理（事件委托）"><a href="#6-事件代理（事件委托）" class="headerlink" title="6.事件代理（事件委托）"></a>6.事件代理（事件委托）</h2><p>我们知道了事件冒泡和事件捕获的原理，那么对于事件委托就比较容易理解了。<br>重复一遍</p><blockquote><p>事件代理就是利用事件冒泡或事件捕获的机制把一系列的内层元素事件绑定到外层元素。<br>至于为什么通常我们说事件代理是利用事件冒泡的机制来实现的，只是大家习以为常而已。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;item-list&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>item1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>item2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>item3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>item4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于上述的列表元素，我们希望将用户点击了哪个item打印出来，通常我们可以给每个item注册点击事件监听器，但是需要对每个元素进行事件监听器的注册；但是通过事件代理，我们可以将多个事件监听器减少为一个，这样就减少代码的重复编写了。</p><p>利用事件冒泡或事件捕获实现事件代理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> items = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;item-list&#x27;</span>);</span><br><span class="line"><span class="comment">//事件捕获实现事件代理</span></span><br><span class="line">items.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&#x27;捕获：click &#x27;</span>,e.target.innerHTML)&#125;, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">//事件冒泡实现事件代理</span></span><br><span class="line">items.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&#x27;冒泡：click &#x27;</span>,e.target.innerHTML)&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当点击列表中的item时，执行结果如下：<br><img src="https://s3.ax1x.com/2020/11/26/D0peJK.png" alt="执行结果"></p><p><strong>因此，事件代理既可以通过事件冒泡来实现，也可以通过事件捕获来实现。</strong></p><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a>7.总结</h2><p>以上的东西总结起来就是有以下几点：</p><ul><li>DOM事件流有3个阶段：捕获阶段，目标阶段，冒泡阶段；三个阶段的顺序为：捕获阶段——目标阶段——冒泡阶段；</li><li>对于非目标阶段的元素，事件响应执行顺序遵循先捕获后冒泡的原则；通过暂缓执行捕获事件，可以达到先冒泡后捕获的效果；</li><li>对于目标元素，事件响应执行顺序根据的事件的执行顺序执行；</li><li>事件捕获是从顶层的Window逐层向内执行，事件冒泡则相反；</li><li>事件委托（事件代理）是根据事件冒泡或事件捕获的机制来实现的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebSocket协议介绍</title>
      <link href="/WebSocket%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D.html"/>
      <url>/WebSocket%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D.html</url>
      
        <content type="html"><![CDATA[<p>WebSocket 是由HTML5提出的一个独立的协议标准。WebSocket可以分为协议（Protocol）和API两部分，分别由IETF和W3C制定了标准。它跟HTTP协议基本没有关系，只是为了兼容现有浏览器的握手规范而对 HTTP 协议的一种补充。更加确切的说 WebSocket 利用了 HTTP 协议来建立连接，仅此而已。</p><a id="more"></a><h1 id="WebSocket-协议介绍"><a href="#WebSocket-协议介绍" class="headerlink" title="WebSocket 协议介绍"></a>WebSocket 协议介绍</h1><p>现在 WebSocket 协议已经成了标准协议，所有主流浏览器都已经很好的支持其基础功能。</p><p>WebSocket 协议实现了浏览器与服务器全双工通信，能更好的节省服务器资源和带宽并达到实时通讯的目的。它与HTTP一样通过已建立的TCP连接来传输数据，但是它和HTTP最大不同是：</p><ol><li><p>WebSocket是一种双向通信协议。在建立连接后，WebSocket服务器端和客户端都能主动向对方发送或接收数据，就像Socket一样；</p></li><li><p>WebSocket需要像TCP一样，先建立连接，连接成功后才能相互通信。</p></li></ol><p><img src="https://s3.ax1x.com/2020/11/18/Dnp0vn.png" alt="握手示意图"></p><p>上图对比可以看出，相对于传统HTTP每次请求-应答都需要客户端与服务端建立连接的模式，WebSocket是类似Socket的TCP长连接通讯模式。一旦WebSocket连接建立后，后续数据都以帧序列的形式传输。在客户端断开WebSocket连接或Server端中断连接前，不需要客户端和服务端重新发起连接请求。在海量并发及客户端与服务器交互负载流量大的情况下，极大的节省了网络带宽资源的消耗，有明显的性能优势，且客户端发送和接受消息是在同一个持久连接上发起，实时性优势明显。</p><h1 id="WebSocket-协议的建立过程"><a href="#WebSocket-协议的建立过程" class="headerlink" title="WebSocket 协议的建立过程"></a>WebSocket 协议的建立过程</h1><p>WebSocket 连接必须由浏览器发起，请求协议是一个标准的HTTP请求（也就是说，WebSocket的建立是依赖HTTP的）。请求报文格式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET ws:<span class="comment">//localhost:3000/ws/chat HTTP/1.1</span></span><br><span class="line">Host: localhost</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Origin: http:<span class="comment">//localhost:3000</span></span><br><span class="line">Sec-WebSocket-Key: client-random-string</span><br><span class="line">Sec-WebSocket-Version: <span class="number">13</span></span><br></pre></td></tr></table></figure><p>该请求和普通的HTTP请求有几点不同：</p><ol><li>其中 HTTP 头部字段 Upgrade: websocket 和 Connection: Upgrade 很重要，告诉服务器通信协议将发生改变，转为 WebSocket 协议。</li><li>Sec-WebSocket-Key是用于标识这个连接，并非用于加密数据；</li><li>Sec-WebSocket-Version指定了WebSocket的协议版本。</li></ol><p>支持 WebSocket 的服务器端在确认以上请求后，应返回状态码为101 Switching Protocols的响应：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">101</span> Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: nRu4KAPUPjjWYrnzxDVeqOxCvlM=</span><br></pre></td></tr></table></figure><p>该响应代码 101 表示本次连接的HTTP协议即将被更改，更改后的协议就是 Upgrade: websocket 指定的WebSocket协议。</p><p>版本号和子协议规定了双方能理解的数据格式，以及是否支持压缩等等。如果仅使用 WebSocket 的 API ，就不需要关心这些。</p><p>现在，一个 WebSocket 连接就建立成功，浏览器和服务器就可以随时主动发送消息给对方。消息有两种，一种是文本，一种是二进制数据。通常，我们可以发送JSON格式的文本，这样，在浏览器处理起来就十分容易。</p><p>为什么 WebSocket 连接可以实现全双工通信而 HTTP 连接不行呢？实际上HTTP协议是建立在TCP协议之上的，TCP协议本身就实现了全双工通信，但是HTTP 协议的请求－应答机制限制了全双工通信。WebSocket连接建立以后，接下来的通信就不使用 HTTP 协议了，直接互相发数据。</p><p>安全的 WebSocket 连接机制和 HTTPS 类似。首先，浏览器用 wss://xxx 创建 WebSocket 连接时，会先通过HTTPS创建安全的连接，然后，该HTTPS 连接升级为 WebSocket 连接，底层通信走的仍然是安全的 SSL/TLS 协议。</p><h1 id="WebSocket-、Ajax-轮询-和-Long-Poll-长轮询-原理解析"><a href="#WebSocket-、Ajax-轮询-和-Long-Poll-长轮询-原理解析" class="headerlink" title="WebSocket 、Ajax 轮询 和 Long Poll(长轮询) 原理解析"></a>WebSocket 、Ajax 轮询 和 Long Poll(长轮询) 原理解析</h1><p>说到 WebSocket ，那就不得不说说 Ajax 轮询 和 Long Poll(长轮询)。</p><p>Ajax 轮询 和 Long Poll(长轮询) 都是 HTTP 请求的应用，都属于非持久连接。</p><p>首先来说说 Ajax 轮询。Ajax 轮询的原理非常简单，让浏览器每隔一定的时间就发送一次请求，询问服务器是否有新信息。</p><p>Long Poll(长轮询) 其实原理跟 Ajax 轮询 差不多，都是采用轮询的方式，不过采取的是阻塞模型，也就是说，客户端发起连接后，如果没消息，服务器不会马上告诉你没消息，而是将这个请求挂起（pending），直到有消息才返回。返回完成或者客户端主动断开后，客户端再次建立连接，周而复始。我们可以看出Long Poll(长轮询) 已经具备了一定的实时性。</p><p>上面这两种应用都是非常消耗资源。Ajax 轮询需要服务器有很快的处理速度和资源。Long Poll(长轮询) 需要有很高的并发，也就是说同时连接数的能力。同时也受到客户端的连接数限制，比如老早的IE6，客户端同事连接数为2。尽管如此，在过去 Ajax 轮询 和 Long Poll(长轮询) 还是有广泛的应用，特别是实时聊天，短消息推送等方面， Long Poll(长轮询) 是除了 Flash 之外唯一的选择。</p><p>相对于 HTTP 连接的非持久连接来说，WebSocket 则是持久连接。</p><p>上面已经说了 WebSocket 是类似 Socket 的TCP长连接通讯模式。一旦 WebSocket 连接建立后，后续数据都以帧序列的形式传输。而且浏览器和服务器就可以随时主动发送消息给对方，是全双工通信。在海量并发及客户端与服务器交互负载流量大的情况下，极大的节省了网络带宽资源的消耗，有明显的性能优势，且客户端发送和接受消息是在同一个持久连接上发起，实时性优势明显。</p><h1 id="WebSocket-API"><a href="#WebSocket-API" class="headerlink" title="WebSocket API"></a>WebSocket API</h1><p>WebSocket 客户端的 API 和流程非常简单：创建 WebSocket 对象，然后指定 open、message等事件的回调即可。其中 message 是客户端与服务器端通过WebSocket通信的关键事件，想要在收到服务器通知后做点什么，写在message事件的回调函数里就好了：</p><h1 id="WebSocket-构造函数"><a href="#WebSocket-构造函数" class="headerlink" title="WebSocket 构造函数"></a>WebSocket 构造函数</h1><p>WebSocket 对象作为一个构造函数，用于新建 WebSocket 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">&#x27;ws://localhost:8080/ws&#x27;</span>);</span><br></pre></td></tr></table></figure><p>执行上面语句之后，客户端就会与服务器进行连接。实例对象的所有属性和方法参见 <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket">https://developer.mozilla.org/en-US/docs/Web/API/WebSocket</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.css88.com/archives/9293">https://www.css88.com/archives/9293</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> websocket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo接入valine评论踩坑</title>
      <link href="/hexo%E6%8E%A5%E5%85%A5valine%E8%AF%84%E8%AE%BA%E9%87%87%E5%9D%91.html"/>
      <url>/hexo%E6%8E%A5%E5%85%A5valine%E8%AF%84%E8%AE%BA%E9%87%87%E5%9D%91.html</url>
      
        <content type="html"><![CDATA[<p>配置过程很简单<br>1、 注册leanCloud，创建应用<br>2、 按照教程配置好AppId和AppKey</p><p>然后问题来了：</p><pre><code>Code 401: 未经授权的操作，请检查你的AppId和AppKey.</code></pre> <a id="more"></a><p>折腾了一个下午，还是没有找到问题所在，后来注册了leanCloud国际版重试了一遍，好了</p><div class="note warning"><p>划重点：一定要注册 <mark class="label danger">leanCloud国际版</mark></p></div>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识websocket</title>
      <link href="/%E5%88%9D%E8%AF%86websocket.html"/>
      <url>/%E5%88%9D%E8%AF%86websocket.html</url>
      
        <content type="html"><![CDATA[<p>首先由一个典型场景引出WebSocket的需求场景，进而阐述WebSocket协议本身。包括其定义，特点以及握手过程报文的解读。最后，再次从协议维度和实现长连接的方法两个方面，对比了HTTP与WebSocket的异同，让读者对WebSocket有更深的认识和理解。</p><a id="more"></a> <h2 id="由一个场景说起"><a href="#由一个场景说起" class="headerlink" title="由一个场景说起"></a>由一个场景说起</h2><p>小明购买了一张机票，在出发前的几个小时，他希望通过航班动态查询软件，实时的了解航班动态，如是否有延误，取消等信息。</p><p>那么这时查询软件与服务器交互如下图：</p><p><img src="https://s3.ax1x.com/2020/11/18/Dm0wZ9.png" alt="Image text"></p><p>很容易理解，每一次航班动态查询，client都需要向server发起请求，然后等待server端的响应结果。当client收到响应后，本次通信的生命周期即宣告结束。</p><p>可是小明说： 我希望只查询一次航班动态，当航班有更新时，服务器可以主动把最新的航班动态信息推送给我！</p><p>怎么办？</p><ul><li>轮询（如ajax的轮询）方式</li></ul><p>即程序内部在小铭第一次请求时，记录下这个请求信息和响应信息，每隔固定时间（例如1分钟）请求一次服务器，服务器返回当前最新状态，对比之前收到的信息，如果相比有变更，则通知小铭；</p><blockquote><p>客户端：有没有新动态(Request)</p><p>服务端：正常起飞（Response）</p><p>客户端：啦啦啦，有没有新动态(Request)</p><p>服务端：正常起飞。。（Response）</p><p>客户端：有没有新动态(Request)</p><p>服务端：你好烦啊，正常起飞。。（Response）</p><p>客户端：有没有新动态（Request）</p><p>服务端：好啦好啦，有啦给你，延误30分钟。。（Response）</p><p>客户端：有没有新动态（Request）</p><p>服务端：没有。。。（Response）</p></blockquote><ul><li>服务端增加延迟答复(长连接)</li></ul><p>即程序内部依然采用轮询方式，不过比上一个方案相比，采取了阻塞方式。（一直打电话，没收到就不挂电话），也就是说，客户端发起连接后，如果服务端没消息，就一直不返回Response给客户端。直到有消息才通知小铭，之后客户端再次建立连接，周而复始。</p><blockquote><p>客户端：有没有新动态，没有的话就等有了才返回给我吧（Request）</p><p>服务端：等到有动态的时候再告诉你。（过了一会儿）来了，给你，延误30分钟（Response）</p><p>客户端：有没有新动态，没有的话就等有了才返回给我吧（Request）</p></blockquote><p>从整个交互的过程来看，这两种都是非常消耗资源的。</p><ul><li>第一种方案,即轮询，需要服务器有很快的处理速度和处理器资源。（训练有素的接线员）</li><li>二种方案，即HTTP长连接（后文还会介绍），需要有很高的并发，也就是说并行处理的能力。（足够多的接线员）</li></ul><p>所以它们都有可能发生下面这种情况：</p><blockquote><p>客户端：有新动态么？</p><p>服务端：问的人太多了，线路正忙，请稍后再试（503 Server Unavailable）<br>客户端：。。。。好吧，有新动态么？</p><p>服务端：问的人太多了，线路正忙，请稍后再试（503 Server Unavailable）</p><p>客户端：。。。。服务端你到底行不行啊。。!@#$%$^&amp;</p></blockquote><p>通过上面这个例子，总结一下我们可以看出，这两种采用HTTP的方式都不是最好的方式，体现在：</p><ul><li>HTTP的被动性：需要很多服务资源。一种需要“接线员”有更快的速度，一种需要更多的“接线员”。这两种都会导致对服务资源（接线员）的需求越来越高。</li><li>HTTP的无状态性：由于接线员只管接电话和处理请求内容，并不会去记录是谁给他们打了电话，每次打电话，都要重新告诉一遍接线员你是谁和你的请求内容是什么。</li></ul><p>那现在想要达到小铭的要求，该怎么办呢？</p><h2 id="WebSocket的真身"><a href="#WebSocket的真身" class="headerlink" title="WebSocket的真身"></a>WebSocket的真身</h2><p>说了这么半天了，让我们言归正传。基于上述的需求和矛盾，WebSocket出现了。</p><p>让我们先来看看，使用了WebSocket以后，上面的场景会变成怎样的流程：</p><blockquote><p>客户端：我要开始使用WebSocket协议，需要的服务：chat(查动态)，WebSocket协议版本：13（HTTP Request）</p><p>服务端：没问题，已升级为WebSocket协议（HTTP Protocols Switched）</p><p>客户端：麻烦航班动态有更新的时候推送通知给我。</p><p>服务端：没问题。</p><p>（……过了10分钟）</p><p>服务端：有动态啦，延误30分钟！</p><p>（……过了30分钟）</p><p>服务端：有动态啦，现在开始登机！</p></blockquote><p>由此可见，</p><ul><li>当使用WebSocket时，服务端可以主动推送信息给客户端了，不必在意客户端等待了多久，不必担心超时断线，解决了被动性问题。</li><li>Websocket只需要一次HTTP交互，来进行协议上的切换，整个通讯过程是建立在一次连接/状态中，也就避免了HTTP的无状态性，服务端会一直知道你的信息，直到你关闭请求，这样就解决了服务端要反复解析HTTP请求头的问题。</li></ul><p>如下图所示：</p><p><img src="https://s3.ax1x.com/2020/11/18/Dm0oJP.png" alt="Image text"></p><h2 id="WebSocket的出生"><a href="#WebSocket的出生" class="headerlink" title="WebSocket的出生"></a>WebSocket的出生</h2><p>WebSocket是HTML5提出的一个协议规范（2011年）附上协议链接：</p><p><a href="https://www.rfc-editor.org/rfc/pdfrfc/rfc6455.txt.pdf">The WebSocket Protocol RFC6455</a> </p><p>WebSocket约定了一个通信的规范，通过一个握手的机制，客户端（如浏览器）和服务器（WebServer）之间能建立一个类似Tcp的连接，从而方便C-S之间的通信。</p><h3 id="WebSocket协议的特点"><a href="#WebSocket协议的特点" class="headerlink" title="WebSocket协议的特点"></a>WebSocket协议的特点</h3><ul><li>建立在 TCP 协议之上，它需要通过握手连接之后才能通信，服务器端的实现比较容易。</li><li>与 HTTP 协议有着良好的兼容性。默认端口也是80或443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</li><li>数据格式比较轻量，性能开销小，通信高效。可以发送文本，也可以发送二进制数据。</li><li>没有同源限制，客户端可以与任意服务器通信。</li><li>协议标识符是ws（如果加密，则为wss），服务器网址就是URL。（例如：ws://<a href="http://www.example.com/chat%EF%BC%89">www.example.com/chat）</a></li><li>它是一种双向通信协议，采用异步回调的方式接受消息，当建立通信连接，可以做到持久性的连接，WebSocket服务器和Browser都能主动的向对方发送或接收数据，实质的推送方式是服务器主动推送，只要有数据就推送到请求方。</li></ul><p>用一张图来描述各个协议的关系：</p><p><img src="https://s3.ax1x.com/2020/11/18/DmDUE9.jpg" alt="Image text"></p><h3 id="WebSocket的通信建立——握手过程"><a href="#WebSocket的通信建立——握手过程" class="headerlink" title="WebSocket的通信建立——握手过程"></a>WebSocket的通信建立——握手过程</h3><p>WebSocket的握手使用HTTP来实现，客户端发送带有Upgrade头的HTTP Request消息。服务端根据请求，做Response。</p><p>请求报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET wss:&#x2F;&#x2F;www.example.cn&#x2F;webSocket HTTP&#x2F;1.1</span><br><span class="line">Host: www.example.cn</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Origin: http:&#x2F;&#x2F;example.cn</span><br><span class="line">Sec-WebSocket-Key: afmbhhBRQuwCLmnWDRWHxw&#x3D;&#x3D;</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits</span><br></pre></td></tr></table></figure><p>详细解释一下：</p><ul><li>第1、2行：与HTTP的Request的请求行一样，这里使用的是HTTPS协议，所以对应的是wss请求。</li><li>第3行：Connection：HTTP1.1中规定Upgrade只能应用在直接连接中。带有Upgrade头的HTTP1.1消息必须含有Connection头，因为Connection头的意义就是，任何接收到此消息的人（往往是代理服务器）都要在转发此消息之前处理掉Connection中指定的域（即不转发Upgrade域）。</li><li>第4行：Upgrade是HTTP1.1中用于定义转换协议的header域。 如果服务器支持的话，客户端希望使用已经建立好的HTTP（TCP）连接，切换到WebSocket协议。</li><li>第5行：Sec-WebSocket-Version标识了客户端支持的WebSocket协议的版本列表。</li><li>第6行：Origin为安全使用，防止跨站攻击，浏览器一般会使用这个来标识原始域。</li><li>第7行：Sec-WebSocket-Key是一个Base64encode的值，这个是客户端随机生成的，用于服务端的验证，服务器会使用此字段组装成另一个key值放在握手返回信息里发送客户端。</li><li>第8行：Sec_WebSocket-Protocol是一个用户定义的字符串，用来区分同URL下，不同的服务所需要的协议，标识了客户端支持的子协议的列表。</li><li>第9行：Sec-WebSocket-Extensions是客户端用来与服务端协商扩展协议的字段，permessage-deflate表示协商是否使用传输数据压缩，client_max_window_bits表示采用LZ77压缩算法时，滑动窗口相关的SIZE大小。</li></ul><p>注：如果对压缩扩展协商的细节感兴趣，可参考下面的RFC7692了解更多细节。 Compression Extensions for WebSocket RFC7692</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 101</span><br><span class="line">Server: nginx&#x2F;1.12.2</span><br><span class="line">Date: Sat, 11 Aug 2018 13:21:27 GMT</span><br><span class="line">Connection: upgrade</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Sec-WebSocket-Accept: sLMyWetYOwus23qJyUD&#x2F;fa1hztc&#x3D;</span><br><span class="line">Sec-WebSocket-Protocol: chat</span><br><span class="line">Sec-WebSocket-Extensions: permessage-deflate;client_max_window_bits&#x3D;15</span><br></pre></td></tr></table></figure><p>详细解释一下：</p><ul><li>第1行：HTTP的版本为HTTP1.1，返回码是101，开始解析Header域（不区分大小写）。</li><li>第2,3行：服务器信息与时间。</li><li>第4行：Connection字段，包含Upgrade。</li><li>第5行：Upgrade字段，包含websocket。</li><li>第6行：Sec-WebSocket-Accept字段，详细介绍一下：<blockquote><p>Sec-WebSocket-Accept字段生成步骤：</p><ol><li><p>将Sec-WebSocket-Key与协议中已定义的一个GUID “258EAFA5-E914-47DA-95CA-C5AB0DC85B11”进行拼接。</p></li><li><p>将步骤1中生成的字符串进行SHA1编码。</p></li><li><p>将步骤2中生成的字符串进行Base64编码。</p></li></ol></blockquote></li></ul><blockquote><p>客户端通过验证服务端返回的Sec-WebSocket-Accept的值, 来确定两件事情:</p></blockquote><blockquote><ol><li><p>服务端是否理解WebSocket协议, 如果服务端不理解,那么它就不会返回正确的Sec-WebSocket-Accept，则建立WebSocket连接失败。</p></li><li><p>服务端返回的Response是对于客户端的此次请求的,而不是之前的缓存。主要是防止有些缓存服务器返回缓存的Response.</p></li></ol></blockquote><ul><li>第7行：Sec-WebSocket-Protocol字段，要判断是否之前的Request握手带有此协议，如果没有，则连接失败。</li><li>第8行：扩展协议协商，支持压缩，且LZZ的滑动窗口大小为15。</li></ul><p>至此，握手过程就完成了，此时的TCP连接不会释放。客户端和服务端可以互相通信了。</p><h2 id="HTTP1-1与WebSocket的异同"><a href="#HTTP1-1与WebSocket的异同" class="headerlink" title="HTTP1.1与WebSocket的异同"></a>HTTP1.1与WebSocket的异同</h2><p>最后，作为总结，让我们再来回顾一下HTTP1.1与WebSocket的相同与不同。加深对WebSocket的理解。</p><h1 id="协议层面的异同"><a href="#协议层面的异同" class="headerlink" title="协议层面的异同"></a>协议层面的异同</h1><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><ul><li>都是基于TCP的应用层协议。</li><li>都使用Request/Response模型进行连接的建立。</li><li>在连接的建立过程中对错误的处理方式相同，在这个阶段WebSocket可能返回和HTTP相同的返回码。</li></ul><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><ul><li>HTTP协议基于Request/Response，只能做单向传输，是半双工协议，而WebSocket是全双工协议，类似于Socket通信，双方都可以在任何时刻向另一方发送数据。</li><li>WebSocket使用HTTP来建立连接，但是定义了一系列新的Header域，这些域在HTTP中并不会使用。换言之，二者的请求头不同。</li><li>WebSocket的连接不能通过中间人来转发，它必须是一个直接连接。如果通过代理转发，一个代理要承受如此多的WebSocket连接不释放，就类似于一次DDOS攻击了。</li><li>WebSocket在建立握手连接时，数据是通过HTTP协议传输的，但在建立连接之后，真正的数据传输阶段是不需要HTTP协议参与的。</li><li>WebSocket传输的数据是二进制流，是以帧为单位的，HTTP传输的是明文传输，是字符串传输，WebSocket的数据帧有序。</li></ul><h1 id="HTTP的长连接与WebSocket的持久连接的异同"><a href="#HTTP的长连接与WebSocket的持久连接的异同" class="headerlink" title="HTTP的长连接与WebSocket的持久连接的异同"></a>HTTP的长连接与WebSocket的持久连接的异同</h1><h3 id="HTTP的两种长连接"><a href="#HTTP的两种长连接" class="headerlink" title="HTTP的两种长连接"></a>HTTP的两种长连接</h3><h4 id="一、HTTP1-1的连接默认使用长连接（Persistent-connection）"><a href="#一、HTTP1-1的连接默认使用长连接（Persistent-connection）" class="headerlink" title="一、HTTP1.1的连接默认使用长连接（Persistent connection）"></a>一、HTTP1.1的连接默认使用长连接（Persistent connection）</h4><p>即在一定的期限内保持链接，客户端会需要在短时间内向服务端请求大量的资源，保持TCP连接不断开。客户端与服务器通信，必须要有客户端发起然后服务器返回结果。客户端是主动的，服务器是被动的。在一个TCP连接上可以传输多个Request/Response消息对，所以本质上还是Request/Response消息对，仍然会造成资源的浪费、实时性不强等问题。如果不是持续连接，即短连接，那么每个资源都要建立一个新的连接，HTTP底层使用的是TCP，那么每次都要使用三次握手建立TCP连接，即每一个request对应一个response，将造成极大的资源浪费。</p><h4 id="二、“长轮询”"><a href="#二、“长轮询”" class="headerlink" title="二、“长轮询”"></a>二、“长轮询”</h4><p>即客户端发送一个超时时间很长的Request，服务器保持住这个连接，在有新数据到达时返回Response</p><h3 id="WebSocket的持久连接"><a href="#WebSocket的持久连接" class="headerlink" title="WebSocket的持久连接"></a>WebSocket的持久连接</h3><p>只需建立一次Request/Response消息对，之后都是TCP连接，避免了需要多次建立Request/Response消息对而产生的冗余头部信息。节省了大量流量和服务器资源。因此被广泛应用于线上WEB游戏和线上聊天室的开发。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 基本使用方法</title>
      <link href="/hello-world.html"/>
      <url>/hello-world.html</url>
      
        <content type="html"><![CDATA[<p>欢迎来到 <a href="https://hexo.io/">Hexo</a>! 这是你的第一篇文章。查看 <a href="https://hexo.io/docs/">文档</a>了解更多信息。 如果您在使用Hexo时遇到任何问题，您可以在 <a href="https://hexo.io/docs/troubleshooting.html">疑难解答</a> 中找到答案，也可以在 <a href="https://github.com/hexojs/hexo/issues">GitHub</a>上问我。</p><a id="more"></a> <h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="创建一篇文章"><a href="#创建一篇文章" class="headerlink" title="创建一篇文章"></a>创建一篇文章</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span>  <span class="comment"># 生成文章，会在source/_posts目录下生成一个abc.md文件</span></span><br></pre></td></tr></table></figure><p>更多信息: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="启动本地服务"><a href="#启动本地服务" class="headerlink" title="启动本地服务"></a>启动本地服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>更多信息: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>更多信息: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="部署博客"><a href="#部署博客" class="headerlink" title="部署博客"></a>部署博客</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>更多信息: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
