<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>js手写系列——手写call、apply、bind方法</title>
      <link href="/js%E6%89%8B%E5%86%99%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E6%89%8B%E5%86%99call%E3%80%81apply%E3%80%81bind%E6%96%B9%E6%B3%95.html"/>
      <url>/js%E6%89%8B%E5%86%99%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E6%89%8B%E5%86%99call%E3%80%81apply%E3%80%81bind%E6%96%B9%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是call、bind、apply？"><a href="#什么是call、bind、apply？" class="headerlink" title="什么是call、bind、apply？"></a>什么是call、bind、apply？</h1><blockquote><p>call，apply，bind是JavaScript中用于改变普通函数this指向（无法改变箭头函数this指向）的方法，这三个函数实际上都是绑定在Function构造函数的prototype上，而每一个函数都是Function的实例，因此每一个函数都可以直接调用call，apply，bind</p></blockquote><h1 id="call、bind、apply的使用"><a href="#call、bind、apply的使用" class="headerlink" title="call、bind、apply的使用"></a>call、bind、apply的使用</h1><h2 id="call方法"><a href="#call方法" class="headerlink" title="call方法"></a>call方法</h2><ul><li>语法： function.call(thisArg, arg1, arg2, …)。 其中thisArg是要设置为函数执行上下文的对象，也就是this要指向的对象，从第二个参数开始，arg1, arg2, … 是传递给函数的参数。通过使用call方法，可以将一个对象的方法应用到另一个对象上。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个对象</span></span><br><span class="line"><span class="keyword">const</span> person1 = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Alice&#x27;</span>,</span><br><span class="line">  greet: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hello, <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>!`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义另一个对象</span></span><br><span class="line"><span class="keyword">const</span> person2 = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Bob&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用call方法将person1的greet方法应用到person2上</span></span><br><span class="line">person1.greet.call(person2); <span class="comment">// 输出：Hello, Bob!</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="apply方法"><a href="#apply方法" class="headerlink" title="apply方法"></a>apply方法</h2><ul><li>语法：function.apply(thisArg, [argsArray])。 其中thisArg是要设置为函数执行上下文的对象，也就是this要指向的对象，argsArray是一个包含参数的数组。通过使用apply方法，可以将一个对象的方法应用到另一个对象上，并使用数组作为参数。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>!`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span> &#125;;</span><br><span class="line">greet.apply(person, [<span class="string">&#x27;Mary&#x27;</span>]); <span class="comment">// 输出：Hello, Mary!</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="bind方法"><a href="#bind方法" class="headerlink" title="bind方法"></a>bind方法</h2><ul><li>语法：function.bind(thisArg, arg1, arg2, …)。 其中thisArg是要绑定到函数执行上下文的对象，也就是this要指向的对象，从第二个参数开始，arg1, arg2, …是传递给函数的参数。与call和apply方法不同，bind方法并不会立即执行函数，而是返回一个新函数，可以稍后调用。这对于事件处理程序和setTimeout函数等场景非常有用。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Hello, &quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> delayedGreet = greet.bind(<span class="literal">null</span>, <span class="string">&quot;John&quot;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(delayedGreet, <span class="number">2000</span>);  <span class="comment">// 2秒后输出：Hello, John</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="call、bind、apply的区别"><a href="#call、bind、apply的区别" class="headerlink" title="call、bind、apply的区别"></a>call、bind、apply的区别</h1><ol><li><p>调用方式：</p><ul><li>call：使用函数的call方法可以直接调用函数，并传递参数列表。</li><li>apply：使用函数的apply方法可以直接调用函数，并传递参数列表，与call方法类似，但参数需要以数组或类数组的形式传递。</li><li>bind：使用函数的bind方法可以返回一个新的函数，这个新函数的this值被绑定到指定的对象，但不会立即执行。</li></ul></li><li><p>参数传递方式：</p><ul><li>call：使用call方法时，参数需要一个一个地列举出来，通过逗号分隔。</li><li>apply：使用apply方法时，参数需要以数组或类数组的形式传递。</li><li>bind：使用bind方法时，可以传递任意数量的参数，可以在绑定时传递参数，也可以在调用时传递参数。</li></ul></li><li><p>执行时机：</p><ul><li>call：调用call方法时，函数会立即执行。</li><li>apply：调用apply方法时，函数会立即执行。</li><li>bind：调用bind方法时，返回一个新函数，需要后续再调用这个新函数才会执行。</li></ul></li></ol><h1 id="手写call、apply、bind方法"><a href="#手写call、apply、bind方法" class="headerlink" title="手写call、apply、bind方法"></a>手写call、apply、bind方法</h1><h2 id="手写call"><a href="#手写call" class="headerlink" title="手写call()"></a>手写call()</h2><ul><li><p>原理：</p><ol><li>首先，通过 <strong>Function.prototype.myCall</strong> 将自定义的 <strong>myCall</strong> 方法添加到所有函数的原型对象上，使得所有函数实例都可以调用该方法。</li><li>在 myCall 方法内部，首先通过 <strong>typeof this !== “function”</strong> 判断调用 <strong>myCall</strong> 的对象是否为函数。如果不是函数，则抛出一个类型错误。</li><li>然后，判断是否传入了上下文对象 <strong>context</strong>。如果没有传入，则将 <strong>context</strong> 赋值为全局对象；ES11 引入了 <strong>globalThis</strong>，它是一个统一的全局对象，无论在浏览器还是 <strong>Node.js</strong> 中，都可以使用 <strong>globalThis</strong> 来访问全局对象, 如果传入的不是对象时，<strong>context</strong> 是一个对应的包装类型。</li><li>接下来，使用 <strong>Symbol</strong> 创建一个唯一的键 <strong>key</strong>，用于将调用 <strong>myCall</strong> 的函数绑定到上下文对象的新属性上。</li><li>将调用 <strong>myCall</strong> 的函数赋值给上下文对象的 <strong>key</strong> 属性，实现了将函数绑定到上下文对象上的效果，使用 <strong>Object.defineProperty</strong> 可以做到使其不被枚举出来。</li><li>调用绑定在上下文对象上的函数，并传入 <strong>myCall</strong> 方法的其他参数 <strong>args</strong>。</li><li>将绑定在上下文对象上的函数删除，以避免对上下文对象造成影响。</li><li>返回函数调用的结果。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">   <span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断调用myCall的是否为函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;Function.prototype.myCall - 被调用的对象必须是函数&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果没有传入上下文对象，则默认为全局对象</span></span><br><span class="line">  <span class="comment">// ES11 引入了 globalThis，它是一个统一的全局对象</span></span><br><span class="line">  <span class="comment">// 无论在浏览器还是 Node.js 中，都可以使用 globalThis 来访问全局对象。</span></span><br><span class="line">  context = context === <span class="literal">null</span> || context === <span class="literal">undefined</span> ?  globalThis : <span class="built_in">Object</span>(context);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用Symbol来创建唯一的key，防止名字冲突</span></span><br><span class="line">  <span class="keyword">const</span> key = <span class="built_in">Symbol</span>();</span><br><span class="line">  <span class="keyword">const</span> fn  = <span class="built_in">this</span>;</span><br><span class="line">  <span class="comment">// this是调用myCall的函数，将函数绑定到上下文对象的新属性上</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(context, key, &#123;</span><br><span class="line">    value: fn,</span><br><span class="line">    configurable: <span class="literal">true</span>  </span><br><span class="line">    <span class="comment">// 需要注意的是，使用 Object.defineProperty() 方法定义的属性默认情况下是不可配置的，这意味着不能使用 delete 关键字删除这些属性。如果需要定义可配置的属性，可以在 descriptor 对象中将 configurable 属性设置为 true。</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// context[key] = this; 这种方式会被枚举出来</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 传入MyCall的多个参数</span></span><br><span class="line">  <span class="keyword">const</span> result = context[key](...args);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将增加的fn方法删除</span></span><br><span class="line">  <span class="keyword">delete</span> context[key];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>测试</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> test = &#123;</span><br><span class="line">  name: <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">  hello: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`hello,<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>!`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  add: <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&quot;world&quot;</span> &#125;;</span><br><span class="line">test.hello.myCall(obj); <span class="comment">//hello,world!</span></span><br><span class="line">test.hello.call(obj);<span class="comment">//hello,world!</span></span><br><span class="line"><span class="built_in">console</span>.log(test.add.myCall(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>));<span class="comment">//3</span></span><br><span class="line"><span class="built_in">console</span>.log(test.add.call(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>));<span class="comment">//3</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="手写apply"><a href="#手写apply" class="headerlink" title="手写apply()"></a>手写apply()</h2><ul><li><p>原理：apply的实现思路跟call类似，就是apply传入参数是以数组的形式传入，所以多了一步判断传入的参数是否为数组以及在调用方法的时候使用扩展运算符 … 将传入的参数数组 argsArr 展开</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span> (<span class="params">context, argsArr</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断调用myApply的是否为函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;Function.prototype.myApply - 被调用的对象必须是函数&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断传入的参数是否为数组</span></span><br><span class="line">  <span class="keyword">if</span> (argsArr &amp;&amp; !<span class="built_in">Array</span>.isArray(argsArr)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;Function.prototype.myApply - 第二个参数必须是数组&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果没有传入上下文对象，则默认为全局对象</span></span><br><span class="line">  <span class="comment">// ES11 引入了 globalThis，它是一个统一的全局对象</span></span><br><span class="line">  <span class="comment">// 无论在浏览器还是 Node.js 中，都可以使用 globalThis 来访问全局对象。</span></span><br><span class="line">  context = context === <span class="literal">null</span> || context === <span class="literal">undefined</span> ?  globalThis : <span class="built_in">Object</span>(context);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//如果第二个参数省略则赋值空数组</span></span><br><span class="line">  argsArr = argsArr || [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用Symbol来创建唯一的key，防止名字冲突</span></span><br><span class="line">  <span class="keyword">const</span> key = <span class="built_in">Symbol</span>();</span><br><span class="line">  <span class="keyword">const</span> key = <span class="built_in">this</span>;</span><br><span class="line">  <span class="comment">// this是调用myApply的函数，将函数绑定到上下文对象的新属性上</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(context, key, &#123;</span><br><span class="line">    value: fn,</span><br><span class="line">    configurable: <span class="literal">true</span>  </span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 传入myApply的多个参数</span></span><br><span class="line">  <span class="keyword">const</span> result = context[key](...argsArr)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将增加的fn方法删除</span></span><br><span class="line">  <span class="keyword">delete</span> context[key];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> test = &#123;</span><br><span class="line">  name: <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">  hello: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`hello,<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>!`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&quot;world&quot;</span> &#125;;</span><br><span class="line">test.hello.myApply(obj); <span class="comment">//hello,world!</span></span><br><span class="line">test.hello.apply(obj); <span class="comment">//hello,world!</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">0</span>]</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max.myApply(<span class="literal">null</span>,arr));<span class="comment">//9</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max.apply(<span class="literal">null</span>,arr));<span class="comment">//9</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="手写bind"><a href="#手写bind" class="headerlink" title="手写bind()"></a>手写bind()</h2><ul><li><p>原理：</p><ol><li>首先，通过 <strong>Function.prototype.myBind</strong> 将自定义的 <strong>myBind</strong> 方法添加到所有函数的原型对象上，使得所有函数实例都可以调用该方法。</li><li>在 <strong>myBind</strong> 方法内部，首先通过 <strong>typeof this !== “function”</strong> 判断调用 <strong>myBind</strong> 的对象是否为函数。如果不是函数，则抛出一个类型错误。</li><li>然后，判断是否传入了上下文对象 <strong>context</strong>。如果没有传入，则将 <strong>context</strong> 赋值为全局对象；ES11 引入了 <strong>globalThis</strong>，它是一个统一的全局对象，无论在浏览器还是 <strong>Node.js</strong> 中，都可以使用 <strong>globalThis</strong> 来访问全局对象。</li><li>保存原始函数的引用，使用 <strong>_this</strong> 变量来表示。</li><li>返回一个新的闭包函数 <strong>fn</strong> 作为绑定函数。这个函数接受任意数量的参数 <strong>innerArgs</strong>。（关于闭包的介绍可以看这篇文章-&gt;闭包的应用场景）</li><li>在返回的函数 <strong>fn</strong> 中，首先判断是否通过 <strong>new</strong> 关键字调用了函数。这里需要注意一点，如果返回出去的函数被当作构造函数使用，即使用 <strong>new</strong> 关键字调用时，<strong>this</strong> 的值会指向新创建的实例对象。通过检查 <strong>this instanceof fn</strong>，可以判断返回出去的函数是否被作为构造函数调用。这里使用 <strong>new _this(…args, …innerArgs)</strong> 来创建新对象。</li><li>如果不是通过 <strong>new</strong> 调用的，就使用 <strong>apply</strong> 方法将原始函数 <strong>_this</strong> 绑定到指定的上下文对象 <strong>context</strong> 上。这里使用 <strong>apply</strong> 方法的目的是将参数数组 <strong>args.concat(innerArgs)</strong> 作为参数传递给原始函数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断调用myBind的是否为函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;Function.prototype.myBind - 被调用的对象必须是函数&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果没有传入上下文对象，则默认为全局对象</span></span><br><span class="line">  <span class="comment">// ES11 引入了 globalThis，它是一个统一的全局对象</span></span><br><span class="line">  <span class="comment">// 无论在浏览器还是 Node.js 中，都可以使用 globalThis 来访问全局对象。</span></span><br><span class="line">  context = context || globalThis;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存原始函数的引用，this就是要绑定的函数</span></span><br><span class="line">  <span class="keyword">const</span> _this = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回一个新的函数作为绑定函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">...innerArgs</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断返回出去的函数有没有被new</span></span><br><span class="line">    <span class="comment">// if(new.target) &#123;  es6判断函数有没有被new</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span> fn) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> _this(...args, ...innerArgs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用apply方法将原函数绑定到指定的上下文对象上</span></span><br><span class="line">    <span class="keyword">return</span> _this.apply(context,args.concat(innerArgs));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>测试</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> test = &#123;</span><br><span class="line">  name: <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">  hello: <span class="function"><span class="keyword">function</span> (<span class="params">a,b,c</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`hello,<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>!`</span>,a+b+c);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&quot;world&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> hello1 = test.hello.myBind(obj,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> hello2 = test.hello.bind(obj,<span class="number">1</span>); </span><br><span class="line">hello1(<span class="number">2</span>,<span class="number">3</span>)<span class="comment">//hello,world! 6</span></span><br><span class="line">hello2(<span class="number">2</span>,<span class="number">3</span>)<span class="comment">//hello,world! 6</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> hello1(<span class="number">2</span>,<span class="number">3</span>));</span><br><span class="line"><span class="comment">//hello,undefined! 6</span></span><br><span class="line"><span class="comment">// hello &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> hello2(<span class="number">2</span>,<span class="number">3</span>));</span><br><span class="line"><span class="comment">//hello,undefined! 6</span></span><br><span class="line"><span class="comment">// hello &#123;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在JavaScript中，call、bind 和 apply 方法是非常有用的工具，我们可以使用call、bind、apply方法来改变函数执行中的this指向，帮助我们更好地控制函数的执行上下文。在实际开发中，这些方法都有各自的应用场景，需要根据具体情况选择使用。</p>]]></content>
      
      
      <categories>
          
          <category> js手写系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js中的this指向问题</title>
      <link href="/js%E4%B8%AD%E7%9A%84this%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98.html"/>
      <url>/js%E4%B8%AD%E7%9A%84this%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<p>结论：<font color="#dd0000">this的值取决于函数是怎么被调用的。</font></p><a id="more"></a><h1 id="背景知识-——-JS-的执行模型与作用域机制"><a href="#背景知识-——-JS-的执行模型与作用域机制" class="headerlink" title="背景知识 —— JS 的执行模型与作用域机制"></a>背景知识 —— JS 的执行模型与作用域机制</h1><p><strong>代码执行的三个阶段</strong><br>编译阶段 -&gt; 创建执行上下文 -&gt; 执行阶段</p><table><thead><tr><th>阶段</th><th>主要作用</th><th>与 this 的关系</th></tr></thead><tbody><tr><td>编译阶段</td><td>词法分析、作用域收集、变量/函数提升</td><td>this 不参与</td></tr><tr><td>创建执行上下文</td><td>构建变量环境和词法环境</td><td>this 未绑定</td></tr><tr><td>执行阶段</td><td>逐行执行语句、函数调用、表达式求值</td><td>this 根据调用方式动态绑定</td></tr></tbody></table><p>this 和变量查找是两码事！</p><ul><li>自由变量查找：沿着作用域链向上查找（编译时确定）</li><li>this 查找：取决于函数如何被调用（运行时决定）<table><thead><tr><th>机制</th><th>查找什么？</th><th>何时确定？</th><th>由什么决定？</th></tr></thead><tbody><tr><td>自由变量（如 myName）</td><td>变量的值</td><td>编译阶段（代码解析时）</td><td>函数定义的位置（词法作用域）</td></tr><tr><td>this</td><td>上下文对象</td><td>运行阶段（函数调用时）</td><td>函数的调用方式</td></tr></tbody></table></li></ul><h1 id="this-的绑定规则"><a href="#this-的绑定规则" class="headerlink" title="this 的绑定规则"></a>this 的绑定规则</h1><p>记住这个口诀 👇</p><blockquote><p>“看调用，不看定义；谁调用，this 就是谁！”</p></blockquote><h2 id="默认绑定：普通函数调用-→-this-全局对象"><a href="#默认绑定：普通函数调用-→-this-全局对象" class="headerlink" title="默认绑定：普通函数调用 → this = 全局对象"></a>默认绑定：普通函数调用 → this = 全局对象</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">// 浏览器中 → window（非严格模式）；严格模式 → undefined</span></span><br></pre></td></tr></table></figure><ul><li>问题：容易意外污染全局（尤其用 var 时，变量会挂到 window 上）</li><li>建议：始终使用 ‘use strict’，让错误提前暴露！使用 let 声明 变量不会挂到window 上</li></ul><h2 id="隐式绑定：作为对象方法调用-→-this-对象本身"><a href="#隐式绑定：作为对象方法调用-→-this-对象本身" class="headerlink" title="隐式绑定：作为对象方法调用 → this = 对象本身"></a>隐式绑定：作为对象方法调用 → this = 对象本身</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  name: <span class="string">&#x27;rafa&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">greet</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hello, <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">user.greet(); <span class="comment">// → &quot;Hello, rafa&quot;</span></span><br><span class="line"><span class="comment">// 其实普通函数调用跟对象方法调用是一回事</span></span><br><span class="line"><span class="comment">// 全局函数声明后会挂在 window 下面，成为window的一个方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rafa</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;my name is rafa&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.rafa() <span class="comment">// &quot;my name is rafa&quot;</span></span><br><span class="line">rafa() <span class="comment">// &quot;my name is rafa&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.rafa === rafa)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>规则：点（.）前面是谁，this 就是谁</li><li>警惕“方法丢失”：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sayHi = user.greet;</span><br><span class="line">sayHi(); <span class="comment">// this = window → &quot;Hello, undefined&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="显式绑定：用-call-apply-bind-强制指定-this"><a href="#显式绑定：用-call-apply-bind-强制指定-this" class="headerlink" title="显式绑定：用 call / apply / bind 强制指定 this"></a>显式绑定：用 call / apply / bind 强制指定 this</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bar = &#123; <span class="attr">myName</span>: <span class="string">&#x27;rafa&#x27;</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.myName = <span class="string">&#x27;hexo&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">updateName.call(bar); <span class="comment">// 强制 this = bar</span></span><br><span class="line"><span class="built_in">console</span>.log(bar.myName); <span class="comment">// → &#x27;hexo&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>这是修复“方法丢失”的终极武器！</li><li>bind 还能创建永久绑定的新函数。</li></ul><h2 id="new-绑定：构造函数调用-→-this-新创建的实例"><a href="#new-绑定：构造函数调用-→-this-新创建的实例" class="headerlink" title="new 绑定：构造函数调用 → this = 新创建的实例"></a>new 绑定：构造函数调用 → this = 新创建的实例</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name; <span class="comment">// this 指向即将返回的新对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Person(<span class="string">&#x27;小明&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p.name); <span class="comment">// → &#x27;小明&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>使用 new 时，JS 会自动：<ol><li>创建空对象</li><li>绑定 this 到该对象</li><li>执行函数体</li><li>返回对象</li></ol></li></ul><h2 id="事件处理函数：this-触发事件的-DOM-元素"><a href="#事件处理函数：this-触发事件的-DOM-元素" class="headerlink" title="事件处理函数：this = 触发事件的 DOM 元素"></a>事件处理函数：this = 触发事件的 DOM 元素</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=<span class="string">&quot;btn&quot;</span>&gt;点我&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// → &lt;button id=&quot;btn&quot;&gt; 元素</span></span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>浏览器自动将 this 绑定到事件目标元素，非常方便！</li></ul><h2 id="箭头函数中的this"><a href="#箭头函数中的this" class="headerlink" title="箭头函数中的this"></a>箭头函数中的this</h2><p>箭头函数不绑定 this，而是继承外层词法作用域的 this</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.name); <span class="comment">// &quot;Bob&quot;</span></span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="绑定优先级总结："><a href="#绑定优先级总结：" class="headerlink" title="绑定优先级总结："></a>绑定优先级总结：</h2><p><strong>new &gt; call/apply/bind &gt; 对象方法 &gt; 普通函数</strong></p><h2 id="为什么-this-设计得这么“奇怪”？"><a href="#为什么-this-设计得这么“奇怪”？" class="headerlink" title="为什么 this 设计得这么“奇怪”？"></a>为什么 this 设计得这么“奇怪”？</h2><p>JavaScript 的 this 常被吐槽，原因有三：</p><ol><li>历史包袱：早期没有类，靠函数模拟 OOP，this 成了“万能胶水”</li><li>默认指向 window：导致全局污染（var a = 1 → window.a = 1）</li><li>动态绑定 vs 静态作用域：与 JS 其他部分的设计哲学冲突</li></ol><p>当然，这种设计也有优点：</p><ol><li>方法可以被多个对象复用（通用工具函数）</li><li>支持强大的“方法借用”（如 Array.prototype.slice.call(arguments)）</li></ol><blockquote><p>🌈 ES6 的箭头函数正是为解决 this 困惑而生：<br>箭头函数没有自己的 this，它继承外层作用域的 this。</p></blockquote><h2 id="终极总结：一张表搞定-this"><a href="#终极总结：一张表搞定-this" class="headerlink" title="终极总结：一张表搞定 this"></a>终极总结：一张表搞定 this</h2><table><thead><tr><th>调用方式</th><th>this 指向</th><th>示例</th></tr></thead><tbody><tr><td>普通调用 fn()</td><td>全局对象（严格模式：undefined）</td><td>foo()</td></tr><tr><td>对象方法 obj.fn()</td><td>obj</td><td>user.getName()</td></tr><tr><td>显式绑定 fn.call(obj)</td><td>obj</td><td>greet.call(person)</td></tr><tr><td>构造函数 new Fn()</td><td>新创建的实例</td><td>new Date()</td></tr><tr><td>事件回调</td><td>触发事件的 DOM 元素</td><td>button.onclick = fn</td></tr><tr><td><strong>牢记三句话：</strong></td><td></td><td></td></tr></tbody></table><ol><li>变量查找看“出生地”，this 查看“谁叫你”</li><li>let/const 不挂 window，var 会挂window —— 少用 var！</li><li>开启 ‘use strict’，让错误无处藏身</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js中的事件循环(Event Loop)</title>
      <link href="/js%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-Event-Loop.html"/>
      <url>/js%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-Event-Loop.html</url>
      
        <content type="html"><![CDATA[<p>事件循环是JavaScript处理异步操作的机制，是浏览器渲染主线程的工作方式。</p><a id="more"></a><h1 id="一、在了解js的事件循环之前，我们先了解一下浏览器有哪些进程线程："><a href="#一、在了解js的事件循环之前，我们先了解一下浏览器有哪些进程线程：" class="headerlink" title="一、在了解js的事件循环之前，我们先了解一下浏览器有哪些进程线程："></a>一、在了解js的事件循环之前，我们先了解一下浏览器有哪些进程线程：</h1><p>首先要明确一点：<strong>浏览器是一个多进程多线程的应用程序</strong>。 浏览器内部工作极其复杂。为了避免相互影响，为了减少连环崩溃的几率，当启动浏览器后，它会自动启动多个进程，每个进程又包含有多个线程。<br><a href="https://imgchr.com/i/pZEfpuD"><img src="https://s41.ax1x.com/2025/11/28/pZEfpuD.png" alt="pZEfpuD.png"></a> </p><blockquote><p>可以在浏览器的任务管理器中查看当前的所有进程 其中，最主要的进程有：</p></blockquote><ol><li>浏览器进程</li></ol><ul><li><strong>功能：</strong>主要负责用户界面的显示和用户交互，包括地址栏、书签、标签页等。</li><li>线程：浏览器进程内部通常会有多个线程，例如：<ul><li><strong>UI线程：</strong>负责处理用户的输入和界面更新。</li><li><strong>定时器线程：</strong>处理定时器事件。</li><li><strong>文件I/O线程：</strong>处理文件读写操作。</li></ul></li></ul><ol start="2"><li>网络进程</li></ol><ul><li><strong>功能：</strong>专门负责网络请求和资源加载，包括从服务器获取HTML、CSS、JavaScript、图片等资源。通过将网络操作与渲染分离，可以提高浏览器的响应速度。</li><li>线程：网络进程内部也会启动多个线程来处理不同的网络任务，例如：<ul><li><strong>请求线程：</strong>负责发送HTTP请求和接收响应。</li><li><strong>缓存线程：</strong>处理缓存的读写操作，以提高资源加载速度</li></ul></li></ul><ol start="3"><li>渲染进程（核心）</li></ol><ul><li><strong>功能：</strong>渲染进程是浏览器的核心部分，负责将网页内容呈现给用户。每个标签页通常会有一个独立的渲染进程，以确保标签页之间的隔离，避免一个标签页的崩溃影响到其他标签页。</li><li>线程：<ul><li><strong>渲染主线程：</strong>负责执行HTML、CSS和JavaScript代码，进行DOM树的构建、样式计算、布局、绘制等。</li><li><strong>合成线程：</strong>负责将渲染结果合成到屏幕上，处理图层的合成和动画效果。</li><li><strong>工作线程：</strong>用于处理一些异步任务，如Web Worker。</li></ul></li></ul><h1 id="二、渲染主线程是如何工作的"><a href="#二、渲染主线程是如何工作的" class="headerlink" title="二、渲染主线程是如何工作的"></a>二、渲染主线程是如何工作的</h1><h2 id="渲染主线程是浏览器中最繁忙的线程，需要它处理的任务包括但不限于："><a href="#渲染主线程是浏览器中最繁忙的线程，需要它处理的任务包括但不限于：" class="headerlink" title="渲染主线程是浏览器中最繁忙的线程，需要它处理的任务包括但不限于："></a>渲染主线程是浏览器中最繁忙的线程，需要它处理的任务包括但不限于：</h2><ul><li>解析 HTML</li><li>解析 CSS</li><li>计算样式</li><li>布局</li><li>处理图层</li><li>每秒把页面画 60 次</li><li>执行全局 JS 代码</li><li>执行事件处理函数</li><li>执行计时器的回调函数</li><li>…<blockquote><p>关于渲染进程为什么不使用多线程来处理这么多任务，js为什么被设计为单线程</p></blockquote></li></ul><ol><li><p>简化执行环境与开发模型<br>单线程模型避免了多线程编程中常见的‌死锁、‌竞态条件等复杂同步问题，降低了学习门槛和运行时错误风险。代码顺序执行特性使开发者更容易预测程序行为，提升开发效率和稳定性</p></li><li><p>保障DOM操作一致性<br> 作为浏览器脚本语言，JavaScript需频繁操作‌DOM。若采用多线程，可能出现线程A添加内容与线程B删除同一节点的冲突，导致浏览器无法确定最终状态。单线程通过顺序执行DOM操作，确保状态一致性。‌‌</p></li><li><p>历史设计与异步处理优化<br>JavaScript诞生之初旨在实现页面动态交互，单线程设计简化了语言实现。通过‌事件循环机制，耗时操作（如网络请求）被放入任务队列，主线程空闲时处理，避免阻塞用户界面。现代异步方案（如‌Promise、‌async/await）进一步提升了可读性。‌‌</p></li></ol><p>为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。</p><h2 id="要处理这么多的任务，主线程遇到了一个前所未有的难题：如何调度任务？-比如："><a href="#要处理这么多的任务，主线程遇到了一个前所未有的难题：如何调度任务？-比如：" class="headerlink" title="要处理这么多的任务，主线程遇到了一个前所未有的难题：如何调度任务？ 比如："></a>要处理这么多的任务，主线程遇到了一个前所未有的难题：如何调度任务？ 比如：</h2><ul><li>我正在执行一个 JS 函数，执行到一半的时候用户点击了按钮，我该立即去执行点击事件的处理函数吗？</li><li>我正在执行一个 JS 函数，执行到一半的时候某个计时器到达了时间，我该立即去执行它的回调吗？</li><li>浏览器进程通知我“用户点击了按钮”，与此同时，某个计时器也到达了时间，我应该处理哪一个呢？</li><li>……<br>渲染主线程想出了一个绝妙的主意来处理这个问题：排队。<br><a href="https://imgchr.com/i/pZE4EX8"><img src="https://s41.ax1x.com/2025/11/28/pZE4EX8.png" alt="pZE4EX8.png"></a></li></ul><ol><li>在最开始的时候，渲染主线程会进入一个无限循环</li><li>每一次循环会检查消息队列中是否有任务存在。如果有，就取出第一个任务执行，执行完一个后进入下一次循环；如果没有，则进入休眠状态。</li><li>其他所有线程（包括其他进程的线程）可以随时向消息队列添加任务。新任务会加到消息队列的末尾。在添加新任务时，如果主线程是休眠状态，则会将其唤醒以继续循环拿取任务，这样一来，就可以让每个任务有条不紊的、持续的进行下去了。</li></ol><p><strong>整个过程，被称之为事件循环（消息循环）</strong></p><h1 id="三、何为异步"><a href="#三、何为异步" class="headerlink" title="三、何为异步"></a>三、何为异步</h1><p>代码在执行过程中，会遇到一些无法立即处理的任务，比如：</p><ul><li>计时完成后需要执行的任务 —— <font color="#dd0000">setTimeout</font>、<font color="#dd0000">setInterval</font></li><li>网络通信完成后需要执行的任务 – <font color="#dd0000">XHR</font>、<font color="#dd0000">Fetch</font></li><li>用户操作后需要执行的任务 – <font color="#dd0000">addEventListener</font></li></ul><p>如果让渲染主线程等待这些任务的时机达到，就会导致主线程长期处于「阻塞」的状态，从而导致浏览器「卡死」<br><a href="https://imgchr.com/i/pZE7MQI"><img src="https://s41.ax1x.com/2025/11/29/pZE7MQI.png" alt="pZE7MQI.png"></a><br><strong>渲染主线程承担着极其重要的工作，无论如何都不能阻塞！</strong> 因此，浏览器选择<strong>异步</strong>来解决这个问题<br><a href="https://imgchr.com/i/pZE7lOP"><img src="https://s41.ax1x.com/2025/11/29/pZE7lOP.png" alt="pZE7lOP.png"></a><br>使用异步的方式，<strong>渲染主线程永不阻塞</strong></p><h1 id="四、任务有优先级吗"><a href="#四、任务有优先级吗" class="headerlink" title="四、任务有优先级吗"></a>四、任务有优先级吗</h1><p>我们都知道事件循环的过程中包含宏任务和微任务的说法，经常讲，事件循环往往从宏任务开始，但是在执行下一个宏任务前，我们需要先将本轮宏任务产生的微任务执行完毕。 那么任务有优先级吗？答案是<strong>没有</strong>。 <strong>但是任务队列有</strong>。 根据 W3C 的最新解释:</p><blockquote><p>每个任务都有一个任务类型，同一个类型的任务必须在一个队列，不同类型的任务可以分属于不同的队列。 在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行。<br>浏览器必须准备好一个微队列，微队列中的任务优先所有其他任务执行 <a href="https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint">https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint</a></p></blockquote><h1 id="五、宏任务队列已经无法满足当前的浏览器要求了"><a href="#五、宏任务队列已经无法满足当前的浏览器要求了" class="headerlink" title="五、宏任务队列已经无法满足当前的浏览器要求了"></a>五、宏任务队列已经无法满足当前的浏览器要求了</h1><p>在目前 chrome 的实现中，至少包含了下面的队列：</p><ul><li>延时队列：用于存放计时器到达后的回调任务，优先级「中」</li><li>交互队列：用于存放用户操作后产生的事件处理任务，优先级「高」</li><li>微队列：用户存放需要最快执行的任务，优先级「最高」</li><li>…..</li></ul><p>以下是模拟浏览器任务调度的伪代码(由豆包生成)，重点体现了三种队列的优先级关系和处理流程：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟浏览器的三种任务队列</span></span><br><span class="line"><span class="keyword">const</span> queues = &#123;</span><br><span class="line">  microtasks: [],         <span class="comment">// 微任务队列（最高优先级）</span></span><br><span class="line">  inputQueue: [],         <span class="comment">// 交互队列（用户输入等）</span></span><br><span class="line">  timerQueue: [],         <span class="comment">// 延时队列（setTimeout/setInterval）</span></span><br><span class="line">  renderingQueue: []      <span class="comment">// 渲染队列（额外补充，用于完整模拟）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务调度器状态</span></span><br><span class="line"><span class="keyword">let</span> isProcessing = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟浏览器的任务处理主循环</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">browserMainLoop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 持续运行的事件循环</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 先处理所有微任务（最高优先级）</span></span><br><span class="line">    processAllMicrotasks();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 检查是否需要渲染（通常在微任务后考虑）</span></span><br><span class="line">    <span class="keyword">if</span> (shouldRender()) &#123;</span><br><span class="line">      processRenderingTasks();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 处理高优先级任务：交互队列（用户输入优先于定时器）</span></span><br><span class="line">    <span class="keyword">if</span> (queues.inputQueue.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      processNextTask(queues.inputQueue);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 处理延时队列任务（优先级低于交互）</span></span><br><span class="line">    <span class="keyword">if</span> (queues.timerQueue.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 只处理已到期的定时器任务</span></span><br><span class="line">      <span class="keyword">const</span> now = getCurrentTime();</span><br><span class="line">      <span class="keyword">const</span> readyTimers = queues.timerQueue.filter(<span class="function"><span class="params">task</span> =&gt;</span> task.expires &lt;= now);</span><br><span class="line">      <span class="keyword">if</span> (readyTimers.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 按到期时间排序，先处理最早到期的</span></span><br><span class="line">        readyTimers.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.expires - b.expires);</span><br><span class="line">        processNextTask(readyTimers);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 若没有任务，进入休眠等待新任务</span></span><br><span class="line">    waitForNewTasks();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理所有微任务（执行到队列为空）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processAllMicrotasks</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (queues.microtasks.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> microtask = queues.microtasks.shift();</span><br><span class="line">    executeTask(microtask);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理单个任务队列中的下一个任务</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processNextTask</span>(<span class="params">queue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (queue.length === <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">  </span><br><span class="line">  isProcessing = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">const</span> task = queue.shift();</span><br><span class="line">  executeTask(task);</span><br><span class="line">  isProcessing = <span class="literal">false</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 执行完一个任务后，再次检查微任务（微任务会在当前任务后立即执行）</span></span><br><span class="line">  processAllMicrotasks();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行任务的具体逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">executeTask</span>(<span class="params">task</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    task.callback();  <span class="comment">// 执行任务的回调函数</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    reportError(error);  <span class="comment">// 处理任务执行中的错误</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数：检查是否需要渲染</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shouldRender</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 简化逻辑：根据浏览器刷新频率（如60Hz约16ms一次）判断是否需要渲染</span></span><br><span class="line">  <span class="keyword">return</span> getCurrentTime() - lastRenderTime &gt; <span class="number">16</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟添加任务的API（对应浏览器提供的API）</span></span><br><span class="line"><span class="keyword">const</span> browser = &#123;</span><br><span class="line">  <span class="comment">// 添加微任务（如Promise.then）</span></span><br><span class="line">  <span class="function"><span class="title">queueMicrotask</span>(<span class="params">callback</span>)</span> &#123;</span><br><span class="line">    queues.microtasks.push(&#123; callback &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 添加延时任务（如setTimeout）</span></span><br><span class="line">  <span class="function"><span class="title">setTimeout</span>(<span class="params">callback, delay</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> expires = getCurrentTime() + delay;</span><br><span class="line">    queues.timerQueue.push(&#123; callback, expires &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 添加交互任务（如click事件）</span></span><br><span class="line">  <span class="function"><span class="title">addInputTask</span>(<span class="params">callback</span>)</span> &#123;</span><br><span class="line">    queues.inputQueue.push(&#123; callback &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 添加渲染任务</span></span><br><span class="line">  <span class="function"><span class="title">requestAnimationFrame</span>(<span class="params">callback</span>)</span> &#123;</span><br><span class="line">    queues.renderingQueue.push(&#123; callback &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="六、核心优先级规则说明："><a href="#六、核心优先级规则说明：" class="headerlink" title="六、核心优先级规则说明："></a>六、核心优先级规则说明：</h1><ol><li><strong>微任务队列（microtasks）优先级最高</strong> - 无论其他队列是否有任务，当前执行栈空闲时会先清空所有微任务 - 对应API：<font color="#dd0000">Promise.then、queueMicrotask、async/await</font>等</li><li><strong>交互队列（inputQueue）次之</strong> - 用户输入（点击、键盘等）任务优先级高于定时器，保证用户操作的响应速度 - 浏览器会优先处理用户交互，避免界面卡顿感</li><li><strong>延时队列（timerQueue）优先级较低</strong> - <font color="#dd0000">setTimeout/setInterval</font>任务仅在没有交互任务时才会被处理 - 定时器的实际执行时间可能比设定时间晚（受队列阻塞影响）</li><li><strong>渲染任务（renderingQueue）适时执行</strong> - 通常在微任务处理后、其他任务执行前检查是否需要渲染 - 遵循显示器刷新率（如60fps），避免过度渲染消耗性能</li></ol><p>这个伪代码简化了浏览器的实际实现，但核心逻辑符合现代浏览器（包括Chrome）的任务调度原则：<strong>优先保证用户交互响应速度，其次处理定时任务，而微任务则始终在当前任务周期内立即完成。</strong></p><p>实际浏览器中，任务调度会更复杂，还会涉及任务优先级动态调整、线程池管理、节能策略等，但上述伪代码已能体现三种队列的核心优先级关系。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文主要从浏览器的渲染进程的视角出发，为大家讲解当前<strong>浏览器环境下</strong>的事件循环是什么样的，如果正在阅读本文的你之前并不了解什么是事件循环，我这里推荐你阅读<a href="https://zhuanlan.zhihu.com/p/9441045906">这篇文章</a>，我相信读完以后，你一定能对事件循环有一定程度的了解。</p><h1 id="面试题：说说事件循环机制"><a href="#面试题：说说事件循环机制" class="headerlink" title="面试题：说说事件循环机制"></a>面试题：说说事件循环机制</h1><ol><li>先说基本知识点，宏任务、微任务有哪些</li><li>说事件循环机制过程，边说边画图出来</li><li>说async/await执行顺序注意，可以把 chrome 的优化，做法其实是违法了规范的，V8 团队的PR这些自信点说出来，显得你很好学，理解得很详细，很透彻。</li><li>把node的事件循环也说一下，重复1、2、3点，node中的第3点要说的是node11前后的事件循环变动点。<br><a href="https://juejin.cn/post/6844904079353708557?searchId=202511282107300C1DA29DEDCF4A231E8F">答案详情</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js中的原型与原型链</title>
      <link href="/js%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE.html"/>
      <url>/js%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE.html</url>
      
        <content type="html"><![CDATA[<p> JavaScript的继承机制基于原型链，它定义了对象属性和方法的查找规则。每个对象都有一个原型，通过原型链，对象能访问到构造函数原型上的方法。<br> <a id="more"></a></p><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p> 在深入探索JavaScript编程的旅程中，理解继承机制是攀登至高技能水平的关键一步。作为这门语言的基石之一，继承不仅支撑着代码的复用性和模块化的实现，还深刻影响着对象间关系的构建与数据结构的设计。其中，原型链扮演着核心角色，它定义了对象属性和方法的查找规则，串联起JavaScript对象的血缘与能力传承。</p><h1 id="原型基础"><a href="#原型基础" class="headerlink" title="原型基础"></a>原型基础</h1><p> 首先，每个JavaScript对象都有一个内置的属性叫做[[Prototype]]，通常通过__proto__访问（非标准但广泛支持），它指向创建该对象的构造函数的prototype属性。构造函数的prototype本身也是一个对象，拥有自己的属性和方法。<br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Animal.prototype.speak = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;I am an animal&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cat = <span class="keyword">new</span> Animal(<span class="string">&#x27;Kitty&#x27;</span>); <span class="comment">// 创建Animal的实例</span></span><br><span class="line"><span class="built_in">console</span>.log(cat);</span><br><span class="line"><span class="built_in">console</span>.log(cat.__proto__ === Animal.prototype)</span><br><span class="line">cat.speak();</span><br></pre></td></tr></table></figure><br> 在这里，cat的__proto__指向Animal.prototype，这意味着cat可以访问Animal.prototype上的方法，如speak。<br> <a href="https://imgchr.com/i/pZA3HhV"><img src="https://s21.ax1x.com/2025/11/25/pZA3HhV.png" alt="pZA3HhV.png"></a></p><h1 id="原型链的形成"><a href="#原型链的形成" class="headerlink" title="原型链的形成"></a>原型链的形成</h1><p>当试图访问一个对象的属性或方法时，如果该对象本身没有定义，JavaScript引擎会向上查找其原型（__proto__指向的对象），这一过程会一直追溯到原型链的顶部，通常是Object.prototype。如果在那里还找不到，就会返回undefined。<br><a href="https://imgchr.com/i/pZA8DvF"><img src="https://s21.ax1x.com/2025/11/25/pZA8DvF.png" alt="pZA8DvF.png"></a><br>图中蓝色的链路及为我们常说的原型链</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(cat.speak === Animal.prototype.speak); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这行代码确认了cat实例的speak方法确实是指向Animal.prototype上的speak方法，证实了继承关系的存在。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat.speak(); <span class="comment">// 输出: &quot;I am an animal&quot;</span></span><br></pre></td></tr></table></figure><p>调用cat.speak()成功执行并打印出”I am an animal”，这证明了cat实例能够正确地沿原型链访问到Animal.prototype上定义的speak方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(cat.toString()); <span class="comment">// 输出：[object Object]</span></span><br></pre></td></tr></table></figure><p>尽管在Animal构造函数或其原型上没有直接定义toString方法，cat.toString()仍然能够执行并按预期工作。这是因为所有JavaScript对象（除非被特殊修改）都默认从Object.prototype继承了toString方法。toString方法通常用于返回对象的字符串表示，对于普通的对象实例，默认情况下返回的是”[object Object]”。</p><blockquote><p>原型链是JavaScript实现继承的核心机制，它允许对象间接访问其原型链上定义的属性和方法，直至达到Object.prototype。这一机制不仅简化了代码复用，也是理解JavaScript面向对象编程的关键。通过上述示例，我们可以看到即便没有在每个对象或构造函数中显式定义所有方法，也可以通过原型链继承自上层原型或最终的Object.prototype，从而获得这些功能。</p></blockquote><h1 id="修改原型的影响"><a href="#修改原型的影响" class="headerlink" title="修改原型的影响"></a>修改原型的影响</h1><p>修改原型对象会影响所有通过该构造函数创建的实例。这是因为所有实例共享同一个原型对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Animal.prototype.speak = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Now I can talk too!&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cat.speak(); <span class="comment">// 输出变为 &quot;Now I can talk too!&quot;</span></span><br></pre></td></tr></table></figure><p>这里，我们修改了Animal.prototype上的speak方法，所有Animal的实例调用speak时都会反映出这一变化。</p><p>由于修改原型会影响到所有通过该构造函数创建的实例，开发中应当谨慎操作，以防止原型污染。一种常见做法是使用不可变（Immutable）的设计模式，或者在必要时为每个实例单独添加方法，而不是修改原型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">giveUniqueVoice</span>(<span class="params">animal, voice</span>) </span>&#123;</span><br><span class="line">   </span><br><span class="line">    animal.speak = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;   </span><br><span class="line">        <span class="built_in">console</span>.log(voice);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> specialCat = <span class="keyword">new</span> Animal(<span class="string">&#x27;Whiskers&#x27;</span>);</span><br><span class="line">giveUniqueVoice(specialCat, <span class="string">&#x27;Meow!&#x27;</span>);</span><br><span class="line"></span><br><span class="line">specialCat.speak(); <span class="comment">// 输出 &quot;Meow!&quot;</span></span><br><span class="line">cat.speak(); <span class="comment">// 输出 &quot;My behavior has been changed!&quot;</span></span><br></pre></td></tr></table></figure><p>在这个例子中，我们通过giveUniqueVoice函数为特定实例specialCat添加了一个独特的speak方法，这样做不会影响到其他Animal实例的行为。</p><h1 id="原型链的尽头"><a href="#原型链的尽头" class="headerlink" title="原型链的尽头"></a>原型链的尽头</h1><p>原型链的尽头，指的是JavaScript中对象原型链层级结构的最终点，这个终点是null。在JavaScript中，每个对象（除null外）都有一个内部属性称为[[Prototype]]，它指向创建该对象的原型对象。这个原型对象本身也可能是一个对象，同样拥有自己的[[Prototype]]，如此形成了所谓的原型链。</p><blockquote><p>当我们尝试访问一个对象的属性或方法时，如果在该对象自身找不到，JavaScript引擎会继续在其原型对象中查找，即沿着原型链向上遍历。这一过程会一直持续到遇到一个原型对象的[[Prototype]]为null的点，这标志着原型链的终点。换句话说，null作为原型链的终点，表示没有更进一步的原型可以继承或查找。</p></blockquote><p>如下代码所示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    name = <span class="string">&#x27;Animal&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">speak</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;I am an animal&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> myDog = <span class="keyword">new</span> Dog(<span class="string">&#x27;Wangcai&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(myDog)</span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/pZAGTzT"><img src="https://s21.ax1x.com/2025/11/25/pZAGTzT.png" alt="pZAGTzT.png"></a></p><ol><li>myDog (Dog实例):</li></ol><ul><li>直接属性：name = ‘Wancai’，这是因为在Dog类的构造函数中，通过super(name)调用了父类Animal的构造函数，并将’Wancai’作为参数传递，从而设置了实例的name属性。</li><li>内部属性[[Prototype]]指向Dog.prototype。</li></ul><ol start="2"><li>Dog.prototype:</li></ol><ul><li>这是Dog类的原型对象，默认包含一个constructor属性指向Dog构造函数自身。</li><li>内部属性[[Prototype]]指向Animal.prototype，因为Dog类通过extends  Animal继承了Animal类，所以其原型链会链接到Animal类的原型对象。</li></ul><ol start="3"><li>Animal.prototype:</li></ol><ul><li>包含了Animal类定义的方法，如speak()。</li><li>内部属性[[Prototype]]指向Object.prototype，这是所有JavaScript对象原型链的标准终点前一站，表明Animal类的原型也是基于基础的JavaScript对象构建的。</li></ul><ol start="4"><li>Object.prototype:</li></ol><ul><li>这是所有JavaScript对象的原型链最终到达的地方，包含了像toString(), valueOf()等基本方法。</li><li>内部属性[[Prototype]]为null，标志着原型链的终点。</li></ul><p>综上所述，myDog的原型链路径如下：</p><ul><li>myDog -&gt; Dog.prototype -&gt; Animal.prototype -&gt; Object.prototype -&gt; null</li></ul><p>这条链展示了从myDog实例出发，逐级向上通过原型链查找属性和方法的过程，直到抵达null，即原型链的顶层。</p><h1 id="为什么null标志着结束？"><a href="#为什么null标志着结束？" class="headerlink" title="为什么null标志着结束？"></a>为什么null标志着结束？</h1><p>null作为Object.prototype的[[ Prototype ]]，是一个特意的设计选择，它表示这条原型链到此为止，没有更进一步的原型可供查找。null既不是对象也不是函数，它是一种特殊的值，用来表示空值或者尚未赋值的状态。在原型链上下文中，它起到了终止链式查找的作用，防止无限循环查找。</p><h1 id="实际意义"><a href="#实际意义" class="headerlink" title="实际意义"></a>实际意义</h1><p>理解原型链的这一终端特性，对开发者来说有几个重要含义：</p><ol><li><strong>性能考量：</strong>它确保了属性查找有一个明确的终点，避免了无止境的循环搜索，从而优化了访问速度。</li><li><strong>对象基础：</strong>揭示了所有对象共享的基本行为，强调了JavaScript中一切皆对象的原则，即使是null这样的特殊值也是对象行为逻辑的一部分。</li><li><strong>继承体系的清晰度：</strong>有助于开发者构建清晰的继承结构，知道何时应该直接在对象上定义方法，何时通过原型链继承，以及如何避免无意中修改基础对象的行为。</li></ol><p>原型链的尽头指向Object.prototype，其[[Prototype]]为null，这一设计精巧地构建了JavaScript对象继承的基础框架。掌握这一概念，对于深入理解对象间的继承关系、避免常见的原型链错误，以及高效地设计和维护代码结构都是至关重要的。它是通往JavaScript高级编程之路上的一块基石。</p><hr><h1 id="继承的实现方式"><a href="#继承的实现方式" class="headerlink" title="继承的实现方式"></a>继承的实现方式</h1><h2 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1. 原型链继承"></a>1. 原型链继承</h2><p>最直接的继承方式就是通过原型链。上面的例子已经展示了这一点，但我们可以更明确地设置原型链：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Animal.prototype.speak = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;I am an animal&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Animal的prototype作为Dog.prototype的原型</span></span><br><span class="line">Dog.prototype = <span class="built_in">Object</span>.create(Animal.prototype);</span><br><span class="line">Dog.prototype.constructor = Dog; <span class="comment">// 修复constructor指向</span></span><br><span class="line"></span><br><span class="line">Dog.prototype.bark = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Woof!&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myDog = <span class="keyword">new</span> Dog(<span class="string">&#x27;Wangcai&#x27;</span>);</span><br><span class="line">myDog.speak(); <span class="comment">// I am an animal</span></span><br><span class="line">myDog.bark(); <span class="comment">// Woof!</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这段代码展示了如何使用原型链继承在JavaScript中实现继承。这里是逐步解析：</p><ul><li><p>定义子类构造函数 Dog:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dog 构造函数接收一个参数 name，并将其作为实例的 name 属性。</p></li><li><p>设置 Dog.prototype 的原型为 Animal.prototype 的副本:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dog.prototype = <span class="built_in">Object</span>.create(Animal.prototype);</span><br></pre></td></tr></table></figure><p>这行代码是关键，它使用 Object.create 方法创建了 Animal.prototype 的一个新对象，然后将其赋值给 Dog.prototype。这样一来，所有通过 Dog 构造函数创建的实例都会在其原型链上找到 Animal.prototype，从而继承了 Animal 的属性和方法。</p></li><li><p>修复 constructor 指向:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dog.prototype.constructor = Dog;</span><br></pre></td></tr></table></figure><p>由于我们直接改变了 Dog.prototype 的指向，原本指向 Dog 的 constructor 现在会指向 Animal。为了修正这一点，我们需要手动将其设置回 Dog。</p></li><li><p>在 Dog.prototype 上定义 bark 方法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Dog.prototype.bark = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Woof!&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这为 Dog 的实例添加了一个独有的方法 bark。</p></li><li><p>创建 Dog 的实例并测试:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myDog = <span class="keyword">new</span> Dog(<span class="string">&#x27;Wangcai&#x27;</span>);</span><br><span class="line">myDog.speak(); <span class="comment">// 输出 &quot;I am an animal&quot;</span></span><br><span class="line">myDog.bark(); <span class="comment">// 输出 &quot;Woof!&quot;</span></span><br></pre></td></tr></table></figure><p>通过 new Dog(‘Wangcai’) 创建了一个名为 “Wangcai” 的狗实例。由于 Dog.prototype 指向了 Animal.prototype 的副本，myDog 可以访问到 Animal 上的 speak 方法。同时，它也有自己特有的 bark 方法。</p></li></ul><p>综上所述，这段代码演示了如何利用原型链实现JavaScript中的继承，让子类能够复用父类的属性和方法，同时也能够扩展自己的特性。</p><ul><li>特点：简单直接，通过将子类型的原型指向父类型的实例，实现方法的继承。</li><li>优点：易于实现，节省内存（共享方法）。</li><li>缺点：父类的引用类型属性会被所有子类实例共享；无法在构造函数中向父类传递参数。</li></ul><h2 id="2-构造函数继承"><a href="#2-构造函数继承" class="headerlink" title="2. 构造函数继承"></a>2. 构造函数继承</h2><p>另一种方式是通过在子类构造函数内部调用超类构造函数，这种方式不涉及原型链，而是直接复制属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">    Animal.call(<span class="built_in">this</span>, name);</span><br><span class="line">    <span class="built_in">this</span>.species = <span class="string">&#x27;Canine&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myDog = <span class="keyword">new</span> Dog(<span class="string">&#x27;Wangcai&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(myDog.name); <span class="comment">// Wangcai</span></span><br><span class="line"><span class="built_in">console</span>.log(myDog.species); <span class="comment">// Canine</span></span><br></pre></td></tr></table></figure><p>这段代码展示了构造函数继承的方式实现JavaScript中的继承。下面是详细的解析：</p><ul><li><p>定义子类构造函数 Dog:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    Animal.call(<span class="built_in">this</span>, name);</span><br><span class="line">    <span class="built_in">this</span>.species = <span class="string">&#x27;Canine&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Dog 构造函数内部，通过 Animal.call(this, name) 调用了 Animal 构造函数。这里的 call 方法改变了 Animal 内部 this 的指向，使其指向当前 Dog 实例，从而使得 Dog 实例能够继承 Animal 的属性。这就是构造函数继承的核心所在。<br>接着，Dog 构造函数还定义了自己的属性 species，设置为 ‘Canine’。</p></li><li><p>创建 Dog 实例并检查属性:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myDog = <span class="keyword">new</span> Dog(<span class="string">&#x27;Wangcai&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(myDog.name); <span class="comment">// 输出 &quot;Wangcai&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(myDog.species); <span class="comment">// 输出 &quot;Canine&quot;</span></span><br></pre></td></tr></table></figure><p>通过 new Dog(‘Wangcai’) 创建了一个 Dog 的实例，并传入名字 ‘Wangcai’。由于在 Dog 构造函数中调用了 Animal.call(this, name)，myDog 实例继承了 Animal 的 name 属性，值为 ‘Wangcai’。同时，myDog 实例还有自己特有的属性 species，值为 ‘Canine’。</p></li></ul><p>总结来说，这段代码演示了如何通过在子类构造函数内部手动调用父类构造函数（并使用 call 或 apply 方法绑定正确的 this 上下文）来实现继承，这种方式允许子类继承父类的属性，同时可以扩展自己的属性和方法。</p><ul><li><strong>特点：</strong>通过在子类构造函数内部调用父类构造函数，实现属性的继承。</li><li><strong>优点：</strong>每个实例都有自己的属性副本，解决了原型链继承中的属性共享问题。</li><li><strong>缺点：</strong>只能继承属性，无法继承方法；每次实例化都会创建方法的新副本，浪费内存。</li></ul><h2 id="3-组合继承（经典继承）"><a href="#3-组合继承（经典继承）" class="headerlink" title="3. 组合继承（经典继承）"></a>3. 组合继承（经典继承）</h2><p>结合原型链继承和构造函数继承，是最常用的继承模式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Animal.prototype.speak = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;I am an animal&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">    Animal.call(<span class="built_in">this</span>, name);</span><br><span class="line">    <span class="built_in">this</span>.species = <span class="string">&#x27;Canine&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Animal的prototype作为Dog.prototype的原型</span></span><br><span class="line">Dog.prototype = <span class="built_in">Object</span>.create(Animal.prototype);</span><br><span class="line">Dog.prototype.constructor = Dog;</span><br><span class="line"></span><br><span class="line">Dog.prototype.bark = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Woof!&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myDog = <span class="keyword">new</span> Dog(<span class="string">&#x27;Wangcai&#x27;</span>);</span><br><span class="line">myDog.speak(); <span class="comment">// I am an animal</span></span><br><span class="line">myDog.bark(); <span class="comment">// Woof!</span></span><br><span class="line"><span class="built_in">console</span>.log(myDog.species); <span class="comment">// Canine</span></span><br></pre></td></tr></table></figure><p>这段代码展示了JavaScript中的一种继承模式，结合了构造函数继承和原型链继承（也称作组合继承），这种组合继承方式综合了构造函数继承和原型链继承的优点，既能够继承实例属性，又能有效复用方法，是JavaScript中较为完善的继承实现方式之一。</p><ul><li><strong>特点：</strong>结合了原型链继承和构造函数继承的优点，是最常用的继承模式。</li><li><strong>优点：</strong>既能继承属性也能继承方法，且每个实例都有自己的属性副本，同时方法又是共享的。</li><li><strong>缺点：</strong>构造函数中调用了两次父类构造函数（一次在子类构造函数内部，一次在原型链设定时），稍微有些冗余。</li></ul><h2 id="ES6-Class继承"><a href="#ES6-Class继承" class="headerlink" title="ES6 Class继承"></a>ES6 Class继承</h2><p>ES6引入了基于class的语法糖，使得继承更加清晰易懂。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义基类 Animal:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"><span class="comment">// Animal 类通过 constructor 方法定义了一个构造器，用于初始化 name 属性，并定义了一个 speak 方法。</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">speak</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;I am an animal&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义子类 Dog 继承 Animal</span></span><br><span class="line"><span class="comment">// extends 关键字表明 Dog 类继承自 Animal 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line"><span class="comment">// 在 Dog 的构造函数中，super(name) 调用了父类的构造函数，传递了参数 name，这是继承父类属性的关键步骤</span></span><br><span class="line">        <span class="built_in">super</span>(name); <span class="comment">// 调用父类构造函数</span></span><br><span class="line">        <span class="built_in">this</span>.species = <span class="string">&#x27;Canine&#x27;</span>; <span class="comment">// 定义了 Dog 特有的属性 species</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义了 Dog 特有的方法 bark。</span></span><br><span class="line">    <span class="function"><span class="title">bark</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Woof!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myDog = <span class="keyword">new</span> Dog(<span class="string">&#x27;Wangcai&#x27;</span>);</span><br><span class="line">myDog.speak(); <span class="comment">// I am an animal</span></span><br><span class="line">myDog.bark(); <span class="comment">// Woof!</span></span><br><span class="line"><span class="built_in">console</span>.log(myDog.species); <span class="comment">// Canine</span></span><br></pre></td></tr></table></figure><p>使用 class 语法实现继承简化了传统构造函数和原型链的复杂性，提供了更接近于其他面向对象语言的继承模型，使得代码更加清晰和易于理解。</p><ul><li><strong>特点：</strong>引入了面向对象编程中的class语法，使得继承的语义更加清晰，更接近其他面向对象语言。</li><li><strong>优点：</strong>语法简洁，易于理解，支持静态方法和类属性，提高了代码的可读性和可维护性。</li><li><strong>缺点：</strong>本质上仍然是基于原型，只是语法糖，新手可能会误解为传统的类继承模型。<blockquote><p>每种继承方式的选择应根据实际项目需求和团队习惯来决定。在ES6及以后的版本中，推荐使用class语法进行继承，它不仅代码更加优雅，而且更易于理解和维护。然而，理解背后的基本原理——原型链和构造函数——对于深入掌握JavaScript的面向对象编程是至关重要的。</p></blockquote></li></ul><h1 id="实战示例：创建可扩展的动物王国"><a href="#实战示例：创建可扩展的动物王国" class="headerlink" title="实战示例：创建可扩展的动物王国"></a>实战示例：创建可扩展的动物王国</h1><ol><li>基础动物类 (Animal)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义基础动物构造函数，接收一个name参数初始化动物名字</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">    <span class="built_in">this</span>.name = name; <span class="comment">// 使用this关键字将传入的name赋值给新创建对象的name属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Animal的原型对象上定义一个speak方法，模拟动物发出声音</span></span><br><span class="line">Animal.prototype.speak = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Some generic sound&#x27;</span>); <span class="comment">// 打印通用的声音文本</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>具体动物类 (Dog &amp; Cat)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dog构造函数，继承Animal</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">    Animal.call(<span class="built_in">this</span>, name); <span class="comment">// 使用Animal.call调用超类构造函数，确保name属性被正确初始化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置Dog的原型为Animal的原型的一个新对象实例，实现继承</span></span><br><span class="line">Dog.prototype = <span class="built_in">Object</span>.create(Animal.prototype);</span><br><span class="line"><span class="comment">// 修复构造函数指针，确保构造函数引用正确</span></span><br><span class="line">Dog.prototype.constructor = Dog;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 覆盖speak方法，使Dog有特定的叫声</span></span><br><span class="line">Dog.prototype.speak = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Woof!&#x27;</span>); <span class="comment">// 打印Dog的叫声</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似的操作创建Cat类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">    Animal.call(<span class="built_in">this</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Cat.prototype = <span class="built_in">Object</span>.create(Animal.prototype);</span><br><span class="line">Cat.prototype.constructor = Cat;</span><br><span class="line"></span><br><span class="line">Cat.prototype.speak = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Meow!&#x27;</span>); <span class="comment">// 打印Cat的叫声</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>实际应用<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Dog和Cat的实例</span></span><br><span class="line"><span class="keyword">const</span> myDog = <span class="keyword">new</span> Dog(<span class="string">&#x27;Wangcai&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> myCat = <span class="keyword">new</span> Cat(<span class="string">&#x27;Whiskers&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用各自的speak方法</span></span><br><span class="line">myDog.speak(); <span class="comment">// 输出: Woof!</span></span><br><span class="line">myCat.speak(); <span class="comment">// 输出: Meow!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态添加行为到Animal原型，所有子类实例都能访问</span></span><br><span class="line">Animal.prototype.sleep = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> is sleeping.`</span>); <span class="comment">// 打印睡觉信息，使用模板字符串插入实例的名字</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用新添加的sleep方法</span></span><br><span class="line">myDog.sleep(); <span class="comment">// 输出: Wangcai is sleeping.</span></span><br><span class="line">myCat.sleep(); <span class="comment">// 输出: Whiskers is sleeping.</span></span><br></pre></td></tr></table></figure>这个示例演示了如何利用原型链实现继承，保持代码的灵活性和扩展性。通过Object.create方法建立原型链关系，确保了子类能够访问父类的属性和方法，同时也能够覆盖或添加新方法以实现特有行为。动物王国的模拟展示了多态性，即不同对象对同一消息（如speak）做出不同响应的能力，以及代码的可维护性和扩展性。</li></ol><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>全面解析了JavaScript中的继承机制，核心围绕原型链这一核心概念展开，阐述了其在对象继承中的作用与重要性，并介绍了几种主要的继承实现方式。以下是文章内容的概括：</p><p>📌 原型基础</p><ul><li>每个JavaScript对象都隐含一个[[Prototype]]属性，通常通过__proto__访问，指向创建它的构造函数的prototype对象。</li><li>构造函数的prototype本身是个对象，包含可被实例共享的方法和属性。</li><li>示例展示了如何通过原型链，实例能访问到构造函数原型上的方法。</li></ul><p>📌 原型链的形成与查找规则</p><ul><li>当访问对象的属性或方法时，若对象自身未定义，则会沿其原型链向上查找，直至Object.prototype，最后到null终止。</li><li>解释了所有对象共享Object.prototype上的基本方法，如toString()等。</li></ul><p>📌 修改原型的影响</p><ul><li>修改原型对象会影响所有通过该构造函数创建的实例，因它们共享同一原型。</li><li>强调需谨慎修改原型以防“原型污染”，建议采用不可变模式或针对实例单独添加方法。</li></ul><p>📌 原型链的尽头</p><ul><li>深入探讨了Object.prototype的[[Prototype]]为null的意义，作为原型链的终点，保证了查找过程的终止。</li></ul><p>📌 继承的实现方式</p><ul><li><strong>原型链继承：</strong>直接设置子类型的原型为父类型的实例，简单直接，共享方法，但需注意构造函数的修正。</li><li><strong>构造函数继承：</strong>子类构造函数内部调用父类构造函数，实现属性继承，但不继承方法且方法不共享。</li><li><strong>组合继承：</strong>结合上述两者，最常用，既继承属性也继承方法，但构造函数被调用两次。</li><li><strong>ES6 Class继承：</strong>引入class语法，简化继承表达，提供更清晰的面向对象编程风格，本质仍是基于原型。</li></ul><p>每种继承方式都有其适用场景与优缺点，理解这些机制有助于开发者根据具体需求选择合适的继承策略，提升代码的效率与可维护性。文章强调了深入理解原型链与构造函数原理对于掌握JavaScript面向对象编程的重要性。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js手写系列——节流函数、防抖函数</title>
      <link href="/js%E6%89%8B%E5%86%99%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E8%8A%82%E6%B5%81%E5%87%BD%E6%95%B0%E3%80%81%E9%98%B2%E6%8A%96%E5%87%BD%E6%95%B0.html"/>
      <url>/js%E6%89%8B%E5%86%99%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E8%8A%82%E6%B5%81%E5%87%BD%E6%95%B0%E3%80%81%E9%98%B2%E6%8A%96%E5%87%BD%E6%95%B0.html</url>
      
        <content type="html"><![CDATA[<p>节流（throttle）是一种常用的性能优化技术，用于限制函数在特定时间间隔内只能执行一次。当频繁触发某个事件时，节流可以确保函数不会过于频繁地执行，从而提升性能。<br>防抖（Debounce）是一种常用的性能优化技术，用于限制函数在短时间内被频繁调用。当事件被触发后，会等待一定时间间隔，如果在这段时间内事件没有被再次触发，才会执行函数。如果在这段时间内事件又被触发，则重新开始计时。</p><a id="more"></a><h1 id="节流函数"><a href="#节流函数" class="headerlink" title="节流函数"></a>节流函数</h1><h2 id="节流的基本概念"><a href="#节流的基本概念" class="headerlink" title="节流的基本概念"></a>节流的基本概念</h2><p>节流的核心思想是：<strong>在一定时间间隔内，无论事件触发多少次，函数只会执行一次。</strong></p><p>与防抖(debounce)不同，防抖是在事件停止触发后延迟执行，而节流是保证在固定时间间隔内至少执行一次。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>窗口大小调整(resize)事件</li><li>页面滚动(scroll)事件</li><li>鼠标移动(mousemove)事件</li><li>输入框实时搜索(减少请求频率)</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ol><li>基础时间戳版节流</li></ol><ul><li>使用时间戳判断是否达到执行间隔</li><li>第一次会立即执行</li><li>停止触发后不会再次执行<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttleBasic</span>(<span class="params">func, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> lastTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> currentTime = <span class="built_in">Date</span>.now();</span><br><span class="line">        <span class="keyword">if</span> (currentTime - lastTime &gt;= delay) &#123;</span><br><span class="line">            func.apply(<span class="built_in">this</span>, args);</span><br><span class="line">            lastTime = currentTime;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>定时器版节流</li></ol><ul><li>使用定时器延迟执行</li><li>第一次不会立即执行</li><li>停止触发后会再执行一次<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttleTimer</span>(<span class="params">func, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeoutId = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!timeoutId) &#123;</span><br><span class="line">            timeoutId = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                func.apply(<span class="built_in">this</span>, args);</span><br><span class="line">                timeoutId = <span class="literal">null</span>;</span><br><span class="line">            &#125;, delay);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>完整版节流（结合时间戳和定时器）</li></ol><ul><li>结合时间戳和定时器</li><li>可配置是否立即执行（leading）和停止后是否执行（trailing)</li><li>功能最完整，适用性最广<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, delay, options = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 函数签名和变量声明</span></span><br><span class="line">    <span class="comment">// func: 需要被节流的原始函数</span></span><br><span class="line">    <span class="comment">// delay: 节流时间间隔（毫秒）</span></span><br><span class="line">    <span class="comment">// options: 配置对象，包含 leading 和 trailing 选项</span></span><br><span class="line">    <span class="comment">// timeoutId: 存储定时器ID，用于取消定时器</span></span><br><span class="line">    <span class="comment">// lastTime: 记录上一次函数执行的时间戳</span></span><br><span class="line">    <span class="comment">// leading: 是否在节流开始时立即执行（默认true）</span></span><br><span class="line">    <span class="comment">// trailing: 是否在节流结束后执行（默认true）</span></span><br><span class="line">    <span class="keyword">let</span> timeoutId, lastTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> &#123; leading = <span class="literal">true</span>, trailing = <span class="literal">true</span> &#125; = options;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回的节流函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 保存原始函数的this上下文和参数</span></span><br><span class="line">        <span class="keyword">const</span> currentTime = <span class="built_in">Date</span>.now();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理leading=false的情况, 如果是第一次调用且leading为false，设置lastTime为当前时间, 这样第一次调用不会立即执行</span></span><br><span class="line">        <span class="keyword">if</span> (!lastTime &amp;&amp; !leading) lastTime = currentTime;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算距离下一次可以执行函数还剩余多少时间, currentTime - lastTime是距离上次执行经过的时间</span></span><br><span class="line">        <span class="keyword">const</span> remainingTime = delay - (currentTime - lastTime);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断是否需要立即执行</span></span><br><span class="line">        <span class="comment">// remainingTime &lt;= 0: 已经超过了节流间隔，可以立即执</span></span><br><span class="line">        <span class="comment">// remainingTime &gt; delay: 处理特殊情况（如系统时间被修改）</span></span><br><span class="line">        <span class="keyword">if</span> (remainingTime &lt;= <span class="number">0</span> || remainingTime &gt; delay) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timeoutId) &#123;</span><br><span class="line">                <span class="comment">// 清除可能存在的定时器</span></span><br><span class="line">                <span class="built_in">clearTimeout</span>(timeoutId);</span><br><span class="line">                timeoutId = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 立即执行原始函数</span></span><br><span class="line">            func.apply(<span class="built_in">this</span>, args);</span><br><span class="line">            <span class="comment">// 更新最后执行时间</span></span><br><span class="line">            lastTime = currentTime;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timeoutId &amp;&amp; trailing) &#123;</span><br><span class="line">            <span class="comment">//  设置延迟执行</span></span><br><span class="line">            <span class="comment">// !timeoutId: 确保不会重复设置定时器</span></span><br><span class="line">            <span class="comment">// trailing: 配置允许在节流结束后执行</span></span><br><span class="line">            timeoutId = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                func.apply(<span class="built_in">this</span>, args);</span><br><span class="line">                lastTime = <span class="built_in">Date</span>.now();</span><br><span class="line">                timeoutId = <span class="literal">null</span>;</span><br><span class="line">            &#125;, remainingTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h2><ul><li>对于需要立即响应的场景（如按钮点击），使用基础时间戳版</li><li>对于需要保证最后一次执行的场景，使用定时器版</li><li>大多数情况下，推荐使用完整版，因为它提供了最灵活的控制选项</li></ul><h1 id="防抖函数"><a href="#防抖函数" class="headerlink" title="防抖函数"></a>防抖函数</h1><h2 id="防抖的核心概念"><a href="#防抖的核心概念" class="headerlink" title="防抖的核心概念"></a>防抖的核心概念</h2><p>防抖的核心思想是：在事件被触发后，等待一定时间间隔，如果在这段时间内事件没有被再次触发，才会执行函数。如果在这段时间内事件再次被触发，则重新计时。</p><h2 id="防抖的工作原理"><a href="#防抖的工作原理" class="headerlink" title="防抖的工作原理"></a>防抖的工作原理</h2><ol><li>事件触发时，设置一个定时器</li><li>如果在定时器结束前事件再次触发，则清除之前的定时器并重新设置</li><li>只有当事件停止触发一段时间后，函数才会执行</li></ol><h2 id="防抖的应用场景"><a href="#防抖的应用场景" class="headerlink" title="防抖的应用场景"></a>防抖的应用场景</h2><ul><li>搜索框输入建议</li><li>窗口大小调整(resize)事件</li><li>表单验证</li><li>按钮点击防重复提交</li><li>自动保存功能</li></ul><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><ol><li>基础防抖函数<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounceBasic</span>(<span class="params">func, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeoutId;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 清除之前的定时器</span></span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeoutId);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置新的定时器</span></span><br><span class="line">        timeoutId = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            func.apply(<span class="built_in">this</span>, args);</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>立即执行版防抖函数<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounceImmediate</span>(<span class="params">func, delay, immediate = <span class="literal">false</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeoutId;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">const</span> callNow = immediate &amp;&amp; !timeoutId;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeoutId);</span><br><span class="line">        </span><br><span class="line">        timeoutId = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            timeoutId = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (!immediate) &#123;</span><br><span class="line">                func.apply(context, args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, delay);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (callNow) &#123;</span><br><span class="line">            func.apply(context, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>增强版防抖函数<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounceEnhanced</span>(<span class="params">func, delay, options = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeoutId;</span><br><span class="line">    <span class="keyword">let</span> lastExecTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> leading = options.leading || <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> trailing = options.trailing !== <span class="literal">false</span>; <span class="comment">// 默认true</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">const</span> currentTime = <span class="built_in">Date</span>.now();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 立即执行逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (leading &amp;&amp; !timeoutId) &#123;</span><br><span class="line">            func.apply(context, args);</span><br><span class="line">            lastExecTime = currentTime;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeoutId);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 延迟执行逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (trailing) &#123;</span><br><span class="line">            timeoutId = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                func.apply(context, args);</span><br><span class="line">                lastExecTime = <span class="built_in">Date</span>.now();</span><br><span class="line">                timeoutId = <span class="literal">null</span>;</span><br><span class="line">            &#125;, delay);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h2 id="防抖与节流的区别"><a href="#防抖与节流的区别" class="headerlink" title="防抖与节流的区别"></a>防抖与节流的区别</h2><table><thead><tr><th>特性</th><th>防抖(Debounce)</th><th>节流(Throttle)</th></tr></thead><tbody><tr><td>执行时机</td><td>在事件停止触发后执行</td><td>在固定时间间隔内执行</td></tr><tr><td>执行次数</td><td>只执行最后一次</td><td>至少执行一次</td></tr><tr><td>适用场景</td><td>搜索框输入、窗口调整</td><td>页面滚动、鼠标移动</td></tr></tbody></table><h1 id="涉及知识点"><a href="#涉及知识点" class="headerlink" title="涉及知识点"></a>涉及知识点</h1><ul><li><a href="https://lirifa.github.io/js%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85.html">闭包</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> js手写系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js中的闭包</title>
      <link href="/js%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85.html"/>
      <url>/js%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85.html</url>
      
        <content type="html"><![CDATA[<p>闭包是JavaScript中一个核心且强大的概念，理解闭包对于掌握JavaScript至关重要。</p><a id="more"></a><h1 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h1><p>闭包是指一个函数能够记住并访问其词法作用域，即使该函数在其词法作用域之外执行。</p><p>简单来说：当一个函数内部定义了另一个函数，并且内部函数引用了外部函数的变量，就形成了闭包。</p><h2 id="闭包的形成条件"><a href="#闭包的形成条件" class="headerlink" title="闭包的形成条件"></a>闭包的形成条件</h2><ul><li>函数嵌套（内部函数定义在外部函数内部）</li><li>内部函数引用外部函数的变量 </li><li>内部函数在外部函数之外被调用</li></ul><h2 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h2><ul><li>数据封装：创建私有变量，实现信息隐藏</li><li>状态保持：函数执行完后，变量仍然保存在内存中</li><li>模块化开发：创建独立的作用域，避免全局污染</li></ul><h2 id="常见应用场景"><a href="#常见应用场景" class="headerlink" title="常见应用场景"></a>常见应用场景</h2><ol><li>创建私有变量和方法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用闭包创建私有变量，只能通过特定方法访问。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createBankAccount</span>(<span class="params">initialBalance</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> balance = initialBalance;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        deposit: <span class="function"><span class="keyword">function</span>(<span class="params">amount</span>) </span>&#123;</span><br><span class="line">            balance += amount;</span><br><span class="line">        &#125;,</span><br><span class="line">        withdraw: <span class="function"><span class="keyword">function</span>(<span class="params">amount</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (amount &lt;= balance) &#123;</span><br><span class="line">                balance -= amount;</span><br><span class="line">                <span class="keyword">return</span> amount;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        getBalance: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> balance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>实现函数柯里化<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将多参数函数转换为一系列单参数函数。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> double = multiply(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> triple = multiply(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(double(<span class="number">5</span>)); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(triple(<span class="number">5</span>)); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure></li><li>模块模式开发<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建具有私有状态和公共接口的模块。</span></span><br><span class="line"><span class="keyword">const</span> myModule = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> privateVar = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> privateVar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        publicMethod: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> privateFunction();</span><br><span class="line">        &#125;,</span><br><span class="line">        increment: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            privateVar++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li><li>事件处理程序<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在事件处理函数中访问外部变量。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupButton</span>(<span class="params">buttonId, message</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> button = <span class="built_in">document</span>.getElementById(buttonId);</span><br><span class="line"></span><br><span class="line">    button.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(message); <span class="comment">// 闭包保留了message的引用</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>防抖和节流函数<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存定时器状态，实现性能优化。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeoutId; <span class="comment">// 闭包保存定时器ID</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeoutId);</span><br><span class="line">        timeoutId = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            func.apply(<span class="built_in">this</span>, args);</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>缓存函数（Memoization）<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">memoize</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 创建缓存键（使用JSON.stringify简化，生产环境建议更健壮的方案）</span></span><br><span class="line">        <span class="keyword">const</span> key = <span class="built_in">JSON</span>.stringify(args);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (cache.has(key)) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;从缓存返回结果&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span> cache.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;计算新结果&#x27;</span>);</span><br><span class="line">        <span class="keyword">const</span> result = fn.apply(<span class="built_in">this</span>, args);</span><br><span class="line">        cache.set(key, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例 - 缓存斐波那契计算</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用记忆化版本</span></span><br><span class="line"><span class="keyword">const</span> memoizedFibonacci = memoize(fibonacci);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(memoizedFibonacci(<span class="number">10</span>)); <span class="comment">// 第一次计算，输出&quot;计算新结果&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(memoizedFibonacci(<span class="number">10</span>)); <span class="comment">// 第二次相同参数，输出&quot;从缓存返回结果&quot;</span></span><br></pre></td></tr></table></figure></li><li>解决循环中的异步问题<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 问题代码</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i); <span class="comment">// 全部输出5</span></span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方案</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(j); <span class="comment">// 输出0,1,2,3,4</span></span><br><span class="line">        &#125;, <span class="number">100</span>);</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>内存管理：闭包会导致变量无法被垃圾回收，可能引起内存泄漏</li><li>性能考虑：过度使用闭包可能影响性能</li><li>正确使用：在不需要时及时解除引用</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>闭包是JavaScript中强大且灵活的特性，正确理解和使用闭包可以写出更加模块化、可维护性更高的代码。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>免费cdn：jsdelivr+github 使用方法</title>
      <link href="/%E5%85%8D%E8%B4%B9cdn%EF%BC%9Ajsdelivr-github-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95.html"/>
      <url>/%E5%85%8D%E8%B4%B9cdn%EF%BC%9Ajsdelivr-github-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。</p><p align="right">——百度百科</p></blockquote><a id="more"></a><p>放在Github的资源在国内加载速度比较慢，因此需要使用CDN加速来优化网站打开速度，jsDelivr + Github便是免费且好用的CDN，非常适合博客网站使用。</p><h2 id="1-新建Github仓库"><a href="#1-新建Github仓库" class="headerlink" title="1.新建Github仓库"></a>1.新建Github仓库</h2><p><img src="https://cdn.jsdelivr.net/gh/lirifa/cdn/img/Snipaste_2021-01-08_15-06-41.png" alt="新建Github仓库"></p><h2 id="2-克隆Github仓库到本地"><a href="#2-克隆Github仓库到本地" class="headerlink" title="2.克隆Github仓库到本地"></a>2.克隆Github仓库到本地</h2><p><img src="https://cdn.jsdelivr.net/gh/lirifa/cdn/img/Snipaste_2021-01-08_15-07-28.png" alt="克隆Github仓库"></p><h2 id="3、上传资源"><a href="#3、上传资源" class="headerlink" title="3、上传资源"></a>3、上传资源</h2><p>复制需要上传的资源到本地git仓库（注：jsDelivr不支持加载超过20M的资源），在本地git仓库目录下右键 Git Bash Here，执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git status                    //查看状态</span><br><span class="line">git add .                     //添加所有文件到暂存区</span><br><span class="line">git commit -m &#x27;第一次提交&#x27;      //把文件提交到仓库</span><br><span class="line">git push                      //推送至远程仓库</span><br></pre></td></tr></table></figure><h2 id="4、发布仓库"><a href="#4、发布仓库" class="headerlink" title="4、发布仓库"></a>4、发布仓库</h2><p>点击发布<br><img src="https://cdn.jsdelivr.net/gh/lirifa/cdn@main/img/Snipaste_2021-01-08_15-30-30.png" alt="发布一个版本"></p><p><img src="https://cdn.jsdelivr.net/gh/lirifa/cdn@main/img/Snipaste_2021-01-08_15-59-42.png" alt="jsdelivr网站"></p><p>从jsdelivr官网发现我们可以有多种方式引用仓库文件<br>分别是</p><ul><li>release</li><li>commit</li><li>branch<br>大多数情况下，我们作为图床使用的话，用branch方式访问比较方便</li></ul><h2 id="5、通过jsDelivr引用资源"><a href="#5、通过jsDelivr引用资源" class="headerlink" title="5、通过jsDelivr引用资源"></a>5、通过jsDelivr引用资源</h2><p>使用方法：</p><ol><li><code>https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径</code></li><li><code>https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@commit/文件路径</code></li><li><code>https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@branch/文件路径</code></li></ol><p>例如</p><blockquote><p><a href="https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@1.0/images/trhx.png">https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@1.0/images/trhx.png</a><br>  <a href="https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@2.0.1/css/style.css">https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@2.0.1/css/style.css</a><br>  <a href="https://cdn.jsdelivr.net/gh/moezx/cdn@3.1.3//The%20Pet%20Girl%20of%20Sakurasou.mp4">https://cdn.jsdelivr.net/gh/moezx/cdn@3.1.3//The%20Pet%20Girl%20of%20Sakurasou.mp4</a></p></blockquote><p>注意：版本号不是必需的，是为了区分新旧资源，如果不使用版本号，将会直接引用最新资源，除此之外还可以使用某个范围内的版本，查看所有资源等，具体使用方法如下：</p><ul><li><p>// 加载任何Github发布、提交或分支<br><a href="https://cdn.jsdelivr.net/gh/user/repo@version/file">https://cdn.jsdelivr.net/gh/user/repo@version/file</a></p></li><li><p>// 加载 jQuery v3.2.1<br><a href="https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/dist/jquery.min.js">https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/dist/jquery.min.js</a></p></li><li><p>// 使用版本范围而不是特定版本<br><a href="https://cdn.jsdelivr.net/gh/jquery/jquery@3.2/dist/jquery.min.js">https://cdn.jsdelivr.net/gh/jquery/jquery@3.2/dist/jquery.min.js</a><br><a href="https://cdn.jsdelivr.net/gh/jquery/jquery@3/dist/jquery.min.js">https://cdn.jsdelivr.net/gh/jquery/jquery@3/dist/jquery.min.js</a></p></li><li><p>// 完全省略该版本以获取最新版本<br><a href="https://cdn.jsdelivr.net/gh/jquery/jquery/dist/jquery.min.js">https://cdn.jsdelivr.net/gh/jquery/jquery/dist/jquery.min.js</a><br><a href="https://cdn.jsdelivr.net/gh/jquery/jquery@latest/dist/jquery.min.js">https://cdn.jsdelivr.net/gh/jquery/jquery@latest/dist/jquery.min.js</a></p></li><li><p>// 将“.min”添加到任何JS/CSS文件中以获取缩小版本，如果不存在，将为会自动生成<br><a href="https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/src/core.min.js">https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/src/core.min.js</a></p></li><li><p>// 在末尾添加 / 以获取资源目录列表<br><a href="https://cdn.jsdelivr.net/gh/jquery/jquery/">https://cdn.jsdelivr.net/gh/jquery/jquery/</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>H5 video开发问题及相关知识点</title>
      <link href="/H5-video%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E5%8F%8A%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9.html"/>
      <url>/H5-video%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E5%8F%8A%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9.html</url>
      
        <content type="html"><![CDATA[<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>video 标签最基本的使用是，指定src并加上controls属性，这样在支持的浏览器上便可以播放了。如果浏览器不支持video标签则会显示标签中的提示文字</p><a id="more"></a><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">&quot;http://clips.vorwaerts-gmbh.de/big_buck_bunny.mp4&quot;</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">    当前浏览器不支持video标签</span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>提示文字可以再放在其他标签中，如再套个p标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">&quot;http://clips.vorwaerts-gmbh.de/big_buck_bunny.mp4&quot;</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span> 当前浏览器不支持video标签 <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="使用source标签"><a href="#使用source标签" class="headerlink" title="使用source标签"></a>使用source标签</h2><p>source标签可以为同一video元素指定不同的视频格式（来源），让浏览器自行选择自己支持的格式播放，不支持的视频源会被忽略</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;some-video.mp4&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/mp4&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;some-video.ogg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/ogg&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span> 当前浏览器不支持video标签 <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="配置多个属性，满足需求"><a href="#配置多个属性，满足需求" class="headerlink" title="配置多个属性，满足需求"></a>配置多个属性，满足需求</h2><p>给video标签设置属性，以满足一定的需求，如loop进行循环播放，width指定video的宽度<br><a href="https://www.w3school.com.cn/tags/tag_video.asp">属性详情</a></p><table><thead><tr><th align="left">属性</th><th align="left">值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">autoplay</td><td align="left">autoplay</td><td align="left">如果出现该属性，则视频在就绪后马上播放。</td></tr><tr><td align="left">controls</td><td align="left">controls</td><td align="left">如果出现该属性，则向用户显示控件，比如播放按钮。</td></tr><tr><td align="left">width</td><td align="left">pixels</td><td align="left">设置视频播放器的宽度。</td></tr><tr><td align="left">height</td><td align="left">pixels</td><td align="left">设置视频播放器的高度。</td></tr><tr><td align="left">loop</td><td align="left">loop</td><td align="left">如果出现该属性，则当媒介文件完成播放后再次开始播放。</td></tr><tr><td align="left">muted</td><td align="left">muted</td><td align="left">规定视频的音频输出应该被静音。</td></tr><tr><td align="left">poster</td><td align="left">URL</td><td align="left">规定视频下载时显示的图像，或者在用户点击播放按钮前显示的图像。</td></tr><tr><td align="left">preload</td><td align="left">preload</td><td align="left">如果出现该属性，则视频在页面加载时进行加载，并预备播放。如果使用 “autoplay”，则忽略该属性。</td></tr><tr><td align="left">src</td><td align="left">url</td><td align="left">要播放的视频的 URL。</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span></span></span><br><span class="line"><span class="tag">    <span class="attr">controls</span></span></span><br><span class="line"><span class="tag">    <span class="attr">loop</span></span></span><br><span class="line"><span class="tag">    <span class="attr">width</span>=<span class="string">&quot;400&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">src</span>=<span class="string">&quot;http://clips.vorwaerts-gmbh.de/big_buck_bunny.mp4&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span>&gt;</span>当前浏览器不支持video标签<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="video点播与直播"><a href="#video点播与直播" class="headerlink" title="video点播与直播"></a>video点播与直播</h2><p> H5 video目前所有浏览器都支持的视频格式是MP4格式，所以mp4应当是点播web视频的首选格式。<br>而在直播视频上，H5 video只在移动端原生支持HLS流的直播视频(Mac safari video标签也支持， PC Chrome不支持)，其他直播流（如FLV）就需要Flash插件的支持。</p><h2 id="video与206状态码"><a href="#video与206状态码" class="headerlink" title="video与206状态码"></a>video与206状态码</h2><p>video播放mp4时，发的依然是get请求，但http返回206状态码， 即partial Content。有关206状态码的相关内容，可以参考下文</p><ul><li><a href="http://blog.aijc.net/server/2015/11/12/HTTP%E5%8D%8F%E8%AE%AE206%E7%8A%B6%E6%80%81%E7%A0%81">Http协议206状态码</a></li></ul><h2 id="终止视频下载"><a href="#终止视频下载" class="headerlink" title="终止视频下载"></a>终止视频下载</h2><p>video.pause() 可以暂停视频播放，但并不能停止视频资源的继续加载，媒体元素会继续加载知道被垃圾回收机制回收。<br>要在暂停播放后立即停止，可使用以下方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">video.pause()</span><br><span class="line">video.src=<span class="string">&#x27;&#x27;</span></span><br><span class="line">video.removeAttribute(<span class="string">&#x27;src&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="切换src地址后重新加载播放"><a href="#切换src地址后重新加载播放" class="headerlink" title="切换src地址后重新加载播放"></a>切换src地址后重新加载播放</h2><p>修改video src 地址后，视频并不会重新的地址加载视频，重新加载可以使用以下方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">video.src=<span class="string">&#x27;新视频地址&#x27;</span></span><br><span class="line">video.load()</span><br><span class="line">video.play()</span><br></pre></td></tr></table></figure><h2 id="防止iOS上默认全屏播放"><a href="#防止iOS上默认全屏播放" class="headerlink" title="防止iOS上默认全屏播放"></a>防止iOS上默认全屏播放</h2><p>ios10及以后的版本，可以通过给video标签加playsinline属性防止iOS默认全屏播放，ios9之前加webkit-playsinline属性，如果要兼容，则把两个属性都加上。</p><p>通过客户端添加配置UIwebview: webview.allowsInlineMediaPlayback = YES，不过还是要求在video元素上加playsinline属性<br>参考</p><ul><li><a href="https://stackoverflow.com/questions/3699552/html5-inline-video-on-iphone-vs-ipad-browser">HTML5 inline video on iPhone vs iPad/Browser</a></li><li><a href="https://developer.apple.com/documentation/uikit/uiwebview/1617960-allowsinlinemediaplayback">allowsInlineMediaPlayback</a></li></ul><h2 id="自动播放及播放控制"><a href="#自动播放及播放控制" class="headerlink" title="自动播放及播放控制"></a>自动播放及播放控制</h2><p>在移动端，有些浏览器支持添加autoplay属性后自动播放，有些设置 autoplay 和 muted属性也能自动播放，比如IOS 10+、Chrome。</p><p>如果想控制什么时候播放，且并不是用户触发的（如没有设置controls），那就设置muted属性，然后调用video.play()方法，隔300ms左右有后，再通过video.muted = false打开声音。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vide.muted = <span class="literal">true</span>;</span><br><span class="line">video.play()</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    video.muted = <span class="literal">false</span></span><br><span class="line">&#125;, <span class="number">300</span>)</span><br></pre></td></tr></table></figure><p>iOS9及之前的版本要求有用户交互才能播放，即手动点击播放按钮或者有用户触发的click、touchend、键盘等事件，然后调用video.play() 方法播放。在iOS9之前，iOS Native可以通过UIWebView的mediaPlaybackRequiresUserAction属性来控制是否需要用户交互。</p><p>使用element.click()触发的click事件是否可以被人为是用户行为？不能<br>浏览器是如何知道是否是用户触发的事件？Event对象的只读属性isTrusted</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test-ele&quot;</span>&gt;</span>这个元素监听事件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> testEle = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#test-ele&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    testEle.addEventlistener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">evt</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 用户触发为true，script或EventTarget.dispatchEvent() 触发为false</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(evt.isTrusted);</span></span><br><span class="line"><span class="javascript">    &#125;, <span class="literal">false</span>);</span></span><br><span class="line"><span class="javascript">    testEle.click() <span class="comment">// 这个触发，evt.isTrusted = false</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>有关iOS 10对safari video的放松策略可以参考: <a href="https://webkit.org/blog/6784/new-video-policies-for-ios/">New <video> Policies for iOS</a></p><h2 id="video-play-的Promise对象（可用于捕获视频播放错误）"><a href="#video-play-的Promise对象（可用于捕获视频播放错误）" class="headerlink" title="video.play() 的Promise对象（可用于捕获视频播放错误）"></a>video.play() 的Promise对象（可用于捕获视频播放错误）</h2><p>在Chrome上，如果没有设置video.muted属性，在非用户行为下，直接使用video.play() 播放，会收到 Uncaught (in promise) DOMException 的报错，视频也没有播放。在iOS下面，可能不会有任何报错，视频也没播放，这样就无法定位问题。</p><p>video.play() 会返回一个Promise对象，如果播放失败，可以通过返回的Promise catch到相关错误信息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pro = video.play();</span><br><span class="line"><span class="keyword">if</span> (pro) &#123;  <span class="comment">// iOS9及以下版本不会返回Promise对象，做下兼容处理</span></span><br><span class="line">   pro.catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123; <span class="built_in">console</span>.log(err) &#125;);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TimeRanges-对象"><a href="#TimeRanges-对象" class="headerlink" title="TimeRanges 对象"></a>TimeRanges 对象</h2><p>在开始获取played属性的时候，以为会返回一个已经播放的时长，实际上返回的是TimeRanges对象，而且看到TimeRanges的length一直不变，当时一脸摸不着头脑，不知道有什么用。后来在做进度控制，需要知道视频已缓冲多少时，才弄明白。</p><p>video DOM对象有三个属性会返回TimeRanges对象，分别为video.played/ video.buffered/ video.seekable</p><p>视频开始时只有一个播放时间段，如果不进行跳跃观看，就一直只有一个时间段，即 TimeRanges.length 值为1；如果进行了跳跃观看（如从2分钟，突然跳进到15分钟的位置），而跳跃内容并没有缓冲完毕，则会出现两个时间段，这时TimeRanges的length为2。所以TimeRanges个数会随着跳跃观看未缓冲完成的内容而增加，随着缓冲的完成而减少，最少为1个，即从开头到结尾。</p><hr><h2 id=""><a href="#" class="headerlink" title="|==========|  |===========| |"></a>|==========|  |===========| |</h2><p>0         5        15  19       21</p><p>TimeRanges对象有一个length属性和start()、play()两个方法：TimeRanges:<br>    length: 1      // 代表当前播放视频存在的播放段<br>    play(index)    // 获取指定播放段的播放（缓冲）开始时间，index从0开始取，以秒计<br>    end(index)     // 获取指定播放段的播放（缓冲）结束时间<br>要获取第一段的开始时间，使用TimeRanges.start(0)，结束时间为TimeRanges.end(0)，第二段TimeRanges.start(1)，以此类推<br>参考</p><ul><li>Media buffering, seeking, and time ranges: (<a href="https://developer.mozilla.org/en-US/docs/Web/Guide/Audio_and_video_delivery/buffering_seeking_time_ranges">https://developer.mozilla.org/en-US/docs/Web/Guide/Audio_and_video_delivery/buffering_seeking_time_ranges</a>)</li><li>Time​Ranges: (<a href="https://developer.mozilla.org/en-US/docs/Web/API/TimeRanges">https://developer.mozilla.org/en-US/docs/Web/API/TimeRanges</a>)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DOM事件流</title>
      <link href="/DOM%E4%BA%8B%E4%BB%B6%E6%B5%81.html"/>
      <url>/DOM%E4%BA%8B%E4%BB%B6%E6%B5%81.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是DOM事件流"><a href="#1-什么是DOM事件流" class="headerlink" title="1.什么是DOM事件流"></a>1.什么是DOM事件流</h2><p>话不多说，先附上W3C链接：<a href="https://www.w3.org/TR/DOM-Level-3-Events/#event-flow">https://www.w3.org/TR/DOM-Level-3-Events/#event-flow</a><br><img src="https://s3.ax1x.com/2020/11/20/DQyEwV.png" alt="www.w3.org/TR/DOM-Leve…"><br>上图是W3C标准的DOM事件流模型图，从图中可以看出，元素事件响应在DOM树中是从顶层的Window开始“流向”目标元素（），然后又从目标元素“流向”顶层的Window。</p><p>通常，我们将这种事件流向分为三个阶段：<strong>捕获阶段</strong>，<strong>目标阶段</strong>，<strong>冒泡阶段</strong>。</p><ul><li>捕获阶段是指事件响应从最外层的Window开始，逐级向内层前进，直到具体事件目标元素。在捕获阶段，不会处理响应元素注册的冒泡事件。</li><li> 目标阶段指触发事件的最底层的元素，如上图中的。</li><li> 冒泡阶段与捕获阶段相反，事件的响应是从最底层开始一层一层往外传递到最外层的Window。</li></ul><p>现在，我们就可以知道，DOM事件流的三个阶段是先捕获阶段，然后是目标阶段，最后才是冒泡阶段。我们时常面试所说的先捕获后冒泡也由此而来。事件代理就是利用事件冒泡或事件捕获的机制把一系列的内层元素事件绑定到外层元素。</p><h2 id="2-事件冒泡和事件捕获"><a href="#2-事件冒泡和事件捕获" class="headerlink" title="2.事件冒泡和事件捕获"></a>2.事件冒泡和事件捕获</h2><p>实际操作中，我们可以通过 element.addEventListener() 设置一个元素的事件模型为冒泡事件或者捕获事件。</p><p>先来看一下 addEventListener 函数的语法： </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.addEventListener(type, listener, useCapture)</span><br></pre></td></tr></table></figure><ul><li>type<br>监听事件类型的字符串  </li><li>listener<br>事件监听回调函数，即事件触发后要处理的函数  </li><li>useCapture<br>默认值false，表示事件冒泡；设为true时，表示事件捕获</li></ul><h2 id="3-事件冒泡举例"><a href="#3-事件冒泡举例" class="headerlink" title="3.事件冒泡举例"></a>3.事件冒泡举例</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;a&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 300px; height: 300px;background-color: red;&quot;</span>&gt;</span></span><br><span class="line">    a</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;b&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 200px; height: 200px;background-color: yellow;&quot;</span>&gt;</span></span><br><span class="line">        b</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;c&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 100px; height: 100px;background-color: #2b9ab4;&quot;</span>&gt;</span></span><br><span class="line">            c</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> a = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;a&#x27;</span>)</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> b = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;b&#x27;</span>)</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> c = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;c&#x27;</span>)</span></span><br><span class="line"><span class="javascript"><span class="comment">//注册冒泡事件监听器</span></span></span><br><span class="line"><span class="javascript">a.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&quot;捕获a&quot;</span>)&#125;)</span></span><br><span class="line"><span class="javascript">b.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&#x27;捕获b&#x27;</span>)&#125;)</span></span><br><span class="line"><span class="javascript">c.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&quot;捕获c&quot;</span>)&#125;)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当我们点击c时，执行结果如下：</p><p><img src="https://s3.ax1x.com/2020/11/20/DQglOs.png" alt="执行结果"></p><p>冒泡事件的执行顺序为：c -&gt; b -&gt; a</p><h2 id="4-事件捕获举例"><a href="#4-事件捕获举例" class="headerlink" title="4.事件捕获举例"></a>4.事件捕获举例</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;a&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 300px; height: 300px;background-color: red;&quot;</span>&gt;</span></span><br><span class="line">    a</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;b&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 200px; height: 200px;background-color: yellow;&quot;</span>&gt;</span></span><br><span class="line">        b</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;c&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 100px; height: 100px;background-color: #2b9ab4;&quot;</span>&gt;</span></span><br><span class="line">            c</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> a = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;a&#x27;</span>)</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> b = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;b&#x27;</span>)</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> c = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;c&#x27;</span>)</span></span><br><span class="line"><span class="javascript"><span class="comment">//注册捕获事件监听器</span></span></span><br><span class="line"><span class="javascript">a.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&quot;捕获a&quot;</span>)&#125;, <span class="literal">true</span>)</span></span><br><span class="line"><span class="javascript">b.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&#x27;捕获b&#x27;</span>)&#125;, <span class="literal">true</span>)</span></span><br><span class="line"><span class="javascript">c.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&quot;捕获c&quot;</span>)&#125;, <span class="literal">true</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当我们点击c时，运行结果如下：<br><img src="https://s3.ax1x.com/2020/11/20/DQgI0I.png" alt="执行结果"><br>捕获事件的执行顺序为：a -&gt; b -&gt; c</p><h2 id="5-事件捕获VS事件冒泡"><a href="#5-事件捕获VS事件冒泡" class="headerlink" title="5.事件捕获VS事件冒泡"></a>5.事件捕获VS事件冒泡</h2><p>我们将上述的代码a,b,c三个元素都注册捕获和冒泡事件，并以元素c作为触发事件的主体，即事件流中的目标阶段。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;a&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 300px; height: 300px;background-color: red;&quot;</span>&gt;</span></span><br><span class="line">    a</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;b&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 200px; height: 200px;background-color: yellow;&quot;</span>&gt;</span></span><br><span class="line">        b</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;c&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 100px; height: 100px;background-color: #2b9ab4;&quot;</span>&gt;</span></span><br><span class="line">            c</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> a = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;a&#x27;</span>)</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> b = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;b&#x27;</span>)</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> c = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;c&#x27;</span>)</span></span><br><span class="line"><span class="javascript"><span class="comment">//注册冒泡事件监听器</span></span></span><br><span class="line"><span class="javascript">a.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&quot;冒泡a&quot;</span>)&#125;)</span></span><br><span class="line"><span class="javascript">b.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&#x27;冒泡b&#x27;</span>)&#125;)</span></span><br><span class="line"><span class="javascript">c.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&quot;冒泡c&quot;</span>)&#125;)</span></span><br><span class="line"><span class="javascript"><span class="comment">//注册捕获事件监听器</span></span></span><br><span class="line"><span class="javascript">a.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&quot;捕获a&quot;</span>)&#125;, <span class="literal">true</span>)</span></span><br><span class="line"><span class="javascript">b.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&#x27;捕获b&#x27;</span>)&#125;, <span class="literal">true</span>)</span></span><br><span class="line"><span class="javascript">c.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&quot;捕获c&quot;</span>)&#125;, <span class="literal">true</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>a,b,c三个元素都是先注册冒泡事件再注册捕获事件，当我们点击c时，执行结果又是如何？请看下图。<br><img src="https://s3.ax1x.com/2020/11/20/DQ2yuj.png" alt="执行结果"><br>从执行结果可以看到，a,b两个元素的事件响应都是先捕获后冒泡的，但对于触发事件的目标元素c，事件的响应并没有遵循先捕获后冒泡的规则</p><p>这是为什么？</p><p>因为<strong>目标元素是事件触发主体处于事件流中的目标阶段，处理事件的顺序是根据注册顺序来执行的。</strong></p><p>我们将上图中c元素的事件注册调换一下顺序</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;a&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 300px; height: 300px;background-color: red;&quot;</span>&gt;</span></span><br><span class="line">    a</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;b&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 200px; height: 200px;background-color: yellow;&quot;</span>&gt;</span></span><br><span class="line">        b</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;c&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 100px; height: 100px;background-color: #2b9ab4;&quot;</span>&gt;</span></span><br><span class="line">            c</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> a = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;a&#x27;</span>)</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> b = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;b&#x27;</span>)</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> c = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;c&#x27;</span>)</span></span><br><span class="line"><span class="javascript"><span class="comment">//注册冒泡事件监听器</span></span></span><br><span class="line"><span class="javascript">a.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&quot;冒泡a&quot;</span>)&#125;)</span></span><br><span class="line"><span class="javascript">b.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&#x27;冒泡b&#x27;</span>)&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="comment">// 事件注册调换顺序</span></span></span><br><span class="line"><span class="javascript">c.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&quot;捕获c&quot;</span>)&#125;, <span class="literal">true</span>)</span></span><br><span class="line"><span class="javascript">c.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&quot;冒泡c&quot;</span>)&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="comment">//注册捕获事件监听器</span></span></span><br><span class="line"><span class="javascript">a.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&quot;捕获a&quot;</span>)&#125;, <span class="literal">true</span>)</span></span><br><span class="line"><span class="javascript">b.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&#x27;捕获b&#x27;</span>)&#125;, <span class="literal">true</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>执行结果：<br><img src="https://s3.ax1x.com/2020/11/20/DQR1I0.png" alt="执行结果"><br>对于非目标元素，如果我们要先执行冒泡事件再执行捕获事件，我们可以在注册监听器时通过暂缓执行捕获事件，等冒泡事件执行完之后，在执行捕获事件。</p><h2 id="6-事件代理（事件委托）"><a href="#6-事件代理（事件委托）" class="headerlink" title="6.事件代理（事件委托）"></a>6.事件代理（事件委托）</h2><p>我们知道了事件冒泡和事件捕获的原理，那么对于事件委托就比较容易理解了。<br>重复一遍</p><blockquote><p>事件代理就是利用事件冒泡或事件捕获的机制把一系列的内层元素事件绑定到外层元素。<br>至于为什么通常我们说事件代理是利用事件冒泡的机制来实现的，只是大家习以为常而已。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;item-list&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>item1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>item2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>item3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>item4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于上述的列表元素，我们希望将用户点击了哪个item打印出来，通常我们可以给每个item注册点击事件监听器，但是需要对每个元素进行事件监听器的注册；但是通过事件代理，我们可以将多个事件监听器减少为一个，这样就减少代码的重复编写了。</p><p>利用事件冒泡或事件捕获实现事件代理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> items = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;item-list&#x27;</span>);</span><br><span class="line"><span class="comment">//事件捕获实现事件代理</span></span><br><span class="line">items.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&#x27;捕获：click &#x27;</span>,e.target.innerHTML)&#125;, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">//事件冒泡实现事件代理</span></span><br><span class="line">items.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&#x27;冒泡：click &#x27;</span>,e.target.innerHTML)&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当点击列表中的item时，执行结果如下：<br><img src="https://s3.ax1x.com/2020/11/26/D0peJK.png" alt="执行结果"></p><p><strong>因此，事件代理既可以通过事件冒泡来实现，也可以通过事件捕获来实现。</strong></p><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a>7.总结</h2><p>以上的东西总结起来就是有以下几点：</p><ul><li>DOM事件流有3个阶段：捕获阶段，目标阶段，冒泡阶段；三个阶段的顺序为：捕获阶段——目标阶段——冒泡阶段；</li><li>对于非目标阶段的元素，事件响应执行顺序遵循先捕获后冒泡的原则；通过暂缓执行捕获事件，可以达到先冒泡后捕获的效果；</li><li>对于目标元素，事件响应执行顺序根据的事件的执行顺序执行；</li><li>事件捕获是从顶层的Window逐层向内执行，事件冒泡则相反；</li><li>事件委托（事件代理）是根据事件冒泡或事件捕获的机制来实现的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebSocket协议介绍</title>
      <link href="/WebSocket%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D.html"/>
      <url>/WebSocket%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D.html</url>
      
        <content type="html"><![CDATA[<p>WebSocket 是由HTML5提出的一个独立的协议标准。WebSocket可以分为协议（Protocol）和API两部分，分别由IETF和W3C制定了标准。它跟HTTP协议基本没有关系，只是为了兼容现有浏览器的握手规范而对 HTTP 协议的一种补充。更加确切的说 WebSocket 利用了 HTTP 协议来建立连接，仅此而已。</p><a id="more"></a><h1 id="WebSocket-协议介绍"><a href="#WebSocket-协议介绍" class="headerlink" title="WebSocket 协议介绍"></a>WebSocket 协议介绍</h1><p>现在 WebSocket 协议已经成了标准协议，所有主流浏览器都已经很好的支持其基础功能。</p><p>WebSocket 协议实现了浏览器与服务器全双工通信，能更好的节省服务器资源和带宽并达到实时通讯的目的。它与HTTP一样通过已建立的TCP连接来传输数据，但是它和HTTP最大不同是：</p><ol><li><p>WebSocket是一种双向通信协议。在建立连接后，WebSocket服务器端和客户端都能主动向对方发送或接收数据，就像Socket一样；</p></li><li><p>WebSocket需要像TCP一样，先建立连接，连接成功后才能相互通信。</p></li></ol><p><img src="https://s3.ax1x.com/2020/11/18/Dnp0vn.png" alt="握手示意图"></p><p>上图对比可以看出，相对于传统HTTP每次请求-应答都需要客户端与服务端建立连接的模式，WebSocket是类似Socket的TCP长连接通讯模式。一旦WebSocket连接建立后，后续数据都以帧序列的形式传输。在客户端断开WebSocket连接或Server端中断连接前，不需要客户端和服务端重新发起连接请求。在海量并发及客户端与服务器交互负载流量大的情况下，极大的节省了网络带宽资源的消耗，有明显的性能优势，且客户端发送和接受消息是在同一个持久连接上发起，实时性优势明显。</p><h1 id="WebSocket-协议的建立过程"><a href="#WebSocket-协议的建立过程" class="headerlink" title="WebSocket 协议的建立过程"></a>WebSocket 协议的建立过程</h1><p>WebSocket 连接必须由浏览器发起，请求协议是一个标准的HTTP请求（也就是说，WebSocket的建立是依赖HTTP的）。请求报文格式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET ws:<span class="comment">//localhost:3000/ws/chat HTTP/1.1</span></span><br><span class="line">Host: localhost</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Origin: http:<span class="comment">//localhost:3000</span></span><br><span class="line">Sec-WebSocket-Key: client-random-string</span><br><span class="line">Sec-WebSocket-Version: <span class="number">13</span></span><br></pre></td></tr></table></figure><p>该请求和普通的HTTP请求有几点不同：</p><ol><li>其中 HTTP 头部字段 Upgrade: websocket 和 Connection: Upgrade 很重要，告诉服务器通信协议将发生改变，转为 WebSocket 协议。</li><li>Sec-WebSocket-Key是用于标识这个连接，并非用于加密数据；</li><li>Sec-WebSocket-Version指定了WebSocket的协议版本。</li></ol><p>支持 WebSocket 的服务器端在确认以上请求后，应返回状态码为101 Switching Protocols的响应：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">101</span> Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: nRu4KAPUPjjWYrnzxDVeqOxCvlM=</span><br></pre></td></tr></table></figure><p>该响应代码 101 表示本次连接的HTTP协议即将被更改，更改后的协议就是 Upgrade: websocket 指定的WebSocket协议。</p><p>版本号和子协议规定了双方能理解的数据格式，以及是否支持压缩等等。如果仅使用 WebSocket 的 API ，就不需要关心这些。</p><p>现在，一个 WebSocket 连接就建立成功，浏览器和服务器就可以随时主动发送消息给对方。消息有两种，一种是文本，一种是二进制数据。通常，我们可以发送JSON格式的文本，这样，在浏览器处理起来就十分容易。</p><p>为什么 WebSocket 连接可以实现全双工通信而 HTTP 连接不行呢？实际上HTTP协议是建立在TCP协议之上的，TCP协议本身就实现了全双工通信，但是HTTP 协议的请求－应答机制限制了全双工通信。WebSocket连接建立以后，接下来的通信就不使用 HTTP 协议了，直接互相发数据。</p><p>安全的 WebSocket 连接机制和 HTTPS 类似。首先，浏览器用 wss://xxx 创建 WebSocket 连接时，会先通过HTTPS创建安全的连接，然后，该HTTPS 连接升级为 WebSocket 连接，底层通信走的仍然是安全的 SSL/TLS 协议。</p><h1 id="WebSocket-、Ajax-轮询-和-Long-Poll-长轮询-原理解析"><a href="#WebSocket-、Ajax-轮询-和-Long-Poll-长轮询-原理解析" class="headerlink" title="WebSocket 、Ajax 轮询 和 Long Poll(长轮询) 原理解析"></a>WebSocket 、Ajax 轮询 和 Long Poll(长轮询) 原理解析</h1><p>说到 WebSocket ，那就不得不说说 Ajax 轮询 和 Long Poll(长轮询)。</p><p>Ajax 轮询 和 Long Poll(长轮询) 都是 HTTP 请求的应用，都属于非持久连接。</p><p>首先来说说 Ajax 轮询。Ajax 轮询的原理非常简单，让浏览器每隔一定的时间就发送一次请求，询问服务器是否有新信息。</p><p>Long Poll(长轮询) 其实原理跟 Ajax 轮询 差不多，都是采用轮询的方式，不过采取的是阻塞模型，也就是说，客户端发起连接后，如果没消息，服务器不会马上告诉你没消息，而是将这个请求挂起（pending），直到有消息才返回。返回完成或者客户端主动断开后，客户端再次建立连接，周而复始。我们可以看出Long Poll(长轮询) 已经具备了一定的实时性。</p><p>上面这两种应用都是非常消耗资源。Ajax 轮询需要服务器有很快的处理速度和资源。Long Poll(长轮询) 需要有很高的并发，也就是说同时连接数的能力。同时也受到客户端的连接数限制，比如老早的IE6，客户端同事连接数为2。尽管如此，在过去 Ajax 轮询 和 Long Poll(长轮询) 还是有广泛的应用，特别是实时聊天，短消息推送等方面， Long Poll(长轮询) 是除了 Flash 之外唯一的选择。</p><p>相对于 HTTP 连接的非持久连接来说，WebSocket 则是持久连接。</p><p>上面已经说了 WebSocket 是类似 Socket 的TCP长连接通讯模式。一旦 WebSocket 连接建立后，后续数据都以帧序列的形式传输。而且浏览器和服务器就可以随时主动发送消息给对方，是全双工通信。在海量并发及客户端与服务器交互负载流量大的情况下，极大的节省了网络带宽资源的消耗，有明显的性能优势，且客户端发送和接受消息是在同一个持久连接上发起，实时性优势明显。</p><h1 id="WebSocket-API"><a href="#WebSocket-API" class="headerlink" title="WebSocket API"></a>WebSocket API</h1><p>WebSocket 客户端的 API 和流程非常简单：创建 WebSocket 对象，然后指定 open、message等事件的回调即可。其中 message 是客户端与服务器端通过WebSocket通信的关键事件，想要在收到服务器通知后做点什么，写在message事件的回调函数里就好了：</p><h1 id="WebSocket-构造函数"><a href="#WebSocket-构造函数" class="headerlink" title="WebSocket 构造函数"></a>WebSocket 构造函数</h1><p>WebSocket 对象作为一个构造函数，用于新建 WebSocket 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">&#x27;ws://localhost:8080/ws&#x27;</span>);</span><br></pre></td></tr></table></figure><p>执行上面语句之后，客户端就会与服务器进行连接。实例对象的所有属性和方法参见 <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket">https://developer.mozilla.org/en-US/docs/Web/API/WebSocket</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.css88.com/archives/9293">https://www.css88.com/archives/9293</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> websocket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo接入valine评论踩坑</title>
      <link href="/hexo%E6%8E%A5%E5%85%A5valine%E8%AF%84%E8%AE%BA%E9%87%87%E5%9D%91.html"/>
      <url>/hexo%E6%8E%A5%E5%85%A5valine%E8%AF%84%E8%AE%BA%E9%87%87%E5%9D%91.html</url>
      
        <content type="html"><![CDATA[<p>配置过程很简单<br>1、 注册leanCloud，创建应用<br>2、 按照教程配置好AppId和AppKey</p><p>然后问题来了：</p><pre><code>Code 401: 未经授权的操作，请检查你的AppId和AppKey.</code></pre> <a id="more"></a><p>折腾了一个下午，还是没有找到问题所在，后来注册了leanCloud国际版重试了一遍，好了</p><div class="note warning"><p>划重点：一定要注册 <mark class="label danger">leanCloud国际版</mark></p></div>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识websocket</title>
      <link href="/%E5%88%9D%E8%AF%86websocket.html"/>
      <url>/%E5%88%9D%E8%AF%86websocket.html</url>
      
        <content type="html"><![CDATA[<p>首先由一个典型场景引出WebSocket的需求场景，进而阐述WebSocket协议本身。包括其定义，特点以及握手过程报文的解读。最后，再次从协议维度和实现长连接的方法两个方面，对比了HTTP与WebSocket的异同，让读者对WebSocket有更深的认识和理解。</p><a id="more"></a> <h2 id="由一个场景说起"><a href="#由一个场景说起" class="headerlink" title="由一个场景说起"></a>由一个场景说起</h2><p>小明购买了一张机票，在出发前的几个小时，他希望通过航班动态查询软件，实时的了解航班动态，如是否有延误，取消等信息。</p><p>那么这时查询软件与服务器交互如下图：</p><p><img src="https://s3.ax1x.com/2020/11/18/Dm0wZ9.png" alt="Image text"></p><p>很容易理解，每一次航班动态查询，client都需要向server发起请求，然后等待server端的响应结果。当client收到响应后，本次通信的生命周期即宣告结束。</p><p>可是小明说： 我希望只查询一次航班动态，当航班有更新时，服务器可以主动把最新的航班动态信息推送给我！</p><p>怎么办？</p><ul><li>轮询（如ajax的轮询）方式</li></ul><p>即程序内部在小铭第一次请求时，记录下这个请求信息和响应信息，每隔固定时间（例如1分钟）请求一次服务器，服务器返回当前最新状态，对比之前收到的信息，如果相比有变更，则通知小铭；</p><blockquote><p>客户端：有没有新动态(Request)</p><p>服务端：正常起飞（Response）</p><p>客户端：啦啦啦，有没有新动态(Request)</p><p>服务端：正常起飞。。（Response）</p><p>客户端：有没有新动态(Request)</p><p>服务端：你好烦啊，正常起飞。。（Response）</p><p>客户端：有没有新动态（Request）</p><p>服务端：好啦好啦，有啦给你，延误30分钟。。（Response）</p><p>客户端：有没有新动态（Request）</p><p>服务端：没有。。。（Response）</p></blockquote><ul><li>服务端增加延迟答复(长连接)</li></ul><p>即程序内部依然采用轮询方式，不过比上一个方案相比，采取了阻塞方式。（一直打电话，没收到就不挂电话），也就是说，客户端发起连接后，如果服务端没消息，就一直不返回Response给客户端。直到有消息才通知小铭，之后客户端再次建立连接，周而复始。</p><blockquote><p>客户端：有没有新动态，没有的话就等有了才返回给我吧（Request）</p><p>服务端：等到有动态的时候再告诉你。（过了一会儿）来了，给你，延误30分钟（Response）</p><p>客户端：有没有新动态，没有的话就等有了才返回给我吧（Request）</p></blockquote><p>从整个交互的过程来看，这两种都是非常消耗资源的。</p><ul><li>第一种方案,即轮询，需要服务器有很快的处理速度和处理器资源。（训练有素的接线员）</li><li>二种方案，即HTTP长连接（后文还会介绍），需要有很高的并发，也就是说并行处理的能力。（足够多的接线员）</li></ul><p>所以它们都有可能发生下面这种情况：</p><blockquote><p>客户端：有新动态么？</p><p>服务端：问的人太多了，线路正忙，请稍后再试（503 Server Unavailable）<br>客户端：。。。。好吧，有新动态么？</p><p>服务端：问的人太多了，线路正忙，请稍后再试（503 Server Unavailable）</p><p>客户端：。。。。服务端你到底行不行啊。。!@#$%$^&amp;</p></blockquote><p>通过上面这个例子，总结一下我们可以看出，这两种采用HTTP的方式都不是最好的方式，体现在：</p><ul><li>HTTP的被动性：需要很多服务资源。一种需要“接线员”有更快的速度，一种需要更多的“接线员”。这两种都会导致对服务资源（接线员）的需求越来越高。</li><li>HTTP的无状态性：由于接线员只管接电话和处理请求内容，并不会去记录是谁给他们打了电话，每次打电话，都要重新告诉一遍接线员你是谁和你的请求内容是什么。</li></ul><p>那现在想要达到小铭的要求，该怎么办呢？</p><h2 id="WebSocket的真身"><a href="#WebSocket的真身" class="headerlink" title="WebSocket的真身"></a>WebSocket的真身</h2><p>说了这么半天了，让我们言归正传。基于上述的需求和矛盾，WebSocket出现了。</p><p>让我们先来看看，使用了WebSocket以后，上面的场景会变成怎样的流程：</p><blockquote><p>客户端：我要开始使用WebSocket协议，需要的服务：chat(查动态)，WebSocket协议版本：13（HTTP Request）</p><p>服务端：没问题，已升级为WebSocket协议（HTTP Protocols Switched）</p><p>客户端：麻烦航班动态有更新的时候推送通知给我。</p><p>服务端：没问题。</p><p>（……过了10分钟）</p><p>服务端：有动态啦，延误30分钟！</p><p>（……过了30分钟）</p><p>服务端：有动态啦，现在开始登机！</p></blockquote><p>由此可见，</p><ul><li>当使用WebSocket时，服务端可以主动推送信息给客户端了，不必在意客户端等待了多久，不必担心超时断线，解决了被动性问题。</li><li>Websocket只需要一次HTTP交互，来进行协议上的切换，整个通讯过程是建立在一次连接/状态中，也就避免了HTTP的无状态性，服务端会一直知道你的信息，直到你关闭请求，这样就解决了服务端要反复解析HTTP请求头的问题。</li></ul><p>如下图所示：</p><p><img src="https://s3.ax1x.com/2020/11/18/Dm0oJP.png" alt="Image text"></p><h2 id="WebSocket的出生"><a href="#WebSocket的出生" class="headerlink" title="WebSocket的出生"></a>WebSocket的出生</h2><p>WebSocket是HTML5提出的一个协议规范（2011年）附上协议链接：</p><p><a href="https://www.rfc-editor.org/rfc/pdfrfc/rfc6455.txt.pdf">The WebSocket Protocol RFC6455</a> </p><p>WebSocket约定了一个通信的规范，通过一个握手的机制，客户端（如浏览器）和服务器（WebServer）之间能建立一个类似Tcp的连接，从而方便C-S之间的通信。</p><h3 id="WebSocket协议的特点"><a href="#WebSocket协议的特点" class="headerlink" title="WebSocket协议的特点"></a>WebSocket协议的特点</h3><ul><li>建立在 TCP 协议之上，它需要通过握手连接之后才能通信，服务器端的实现比较容易。</li><li>与 HTTP 协议有着良好的兼容性。默认端口也是80或443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</li><li>数据格式比较轻量，性能开销小，通信高效。可以发送文本，也可以发送二进制数据。</li><li>没有同源限制，客户端可以与任意服务器通信。</li><li>协议标识符是ws（如果加密，则为wss），服务器网址就是URL。（例如：ws://<a href="http://www.example.com/chat%EF%BC%89">www.example.com/chat）</a></li><li>它是一种双向通信协议，采用异步回调的方式接受消息，当建立通信连接，可以做到持久性的连接，WebSocket服务器和Browser都能主动的向对方发送或接收数据，实质的推送方式是服务器主动推送，只要有数据就推送到请求方。</li></ul><p>用一张图来描述各个协议的关系：</p><p><img src="https://s3.ax1x.com/2020/11/18/DmDUE9.jpg" alt="Image text"></p><h3 id="WebSocket的通信建立——握手过程"><a href="#WebSocket的通信建立——握手过程" class="headerlink" title="WebSocket的通信建立——握手过程"></a>WebSocket的通信建立——握手过程</h3><p>WebSocket的握手使用HTTP来实现，客户端发送带有Upgrade头的HTTP Request消息。服务端根据请求，做Response。</p><p>请求报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET wss:&#x2F;&#x2F;www.example.cn&#x2F;webSocket HTTP&#x2F;1.1</span><br><span class="line">Host: www.example.cn</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Origin: http:&#x2F;&#x2F;example.cn</span><br><span class="line">Sec-WebSocket-Key: afmbhhBRQuwCLmnWDRWHxw&#x3D;&#x3D;</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits</span><br></pre></td></tr></table></figure><p>详细解释一下：</p><ul><li>第1、2行：与HTTP的Request的请求行一样，这里使用的是HTTPS协议，所以对应的是wss请求。</li><li>第3行：Connection：HTTP1.1中规定Upgrade只能应用在直接连接中。带有Upgrade头的HTTP1.1消息必须含有Connection头，因为Connection头的意义就是，任何接收到此消息的人（往往是代理服务器）都要在转发此消息之前处理掉Connection中指定的域（即不转发Upgrade域）。</li><li>第4行：Upgrade是HTTP1.1中用于定义转换协议的header域。 如果服务器支持的话，客户端希望使用已经建立好的HTTP（TCP）连接，切换到WebSocket协议。</li><li>第5行：Sec-WebSocket-Version标识了客户端支持的WebSocket协议的版本列表。</li><li>第6行：Origin为安全使用，防止跨站攻击，浏览器一般会使用这个来标识原始域。</li><li>第7行：Sec-WebSocket-Key是一个Base64encode的值，这个是客户端随机生成的，用于服务端的验证，服务器会使用此字段组装成另一个key值放在握手返回信息里发送客户端。</li><li>第8行：Sec_WebSocket-Protocol是一个用户定义的字符串，用来区分同URL下，不同的服务所需要的协议，标识了客户端支持的子协议的列表。</li><li>第9行：Sec-WebSocket-Extensions是客户端用来与服务端协商扩展协议的字段，permessage-deflate表示协商是否使用传输数据压缩，client_max_window_bits表示采用LZ77压缩算法时，滑动窗口相关的SIZE大小。</li></ul><p>注：如果对压缩扩展协商的细节感兴趣，可参考下面的RFC7692了解更多细节。 Compression Extensions for WebSocket RFC7692</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 101</span><br><span class="line">Server: nginx&#x2F;1.12.2</span><br><span class="line">Date: Sat, 11 Aug 2018 13:21:27 GMT</span><br><span class="line">Connection: upgrade</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Sec-WebSocket-Accept: sLMyWetYOwus23qJyUD&#x2F;fa1hztc&#x3D;</span><br><span class="line">Sec-WebSocket-Protocol: chat</span><br><span class="line">Sec-WebSocket-Extensions: permessage-deflate;client_max_window_bits&#x3D;15</span><br></pre></td></tr></table></figure><p>详细解释一下：</p><ul><li>第1行：HTTP的版本为HTTP1.1，返回码是101，开始解析Header域（不区分大小写）。</li><li>第2,3行：服务器信息与时间。</li><li>第4行：Connection字段，包含Upgrade。</li><li>第5行：Upgrade字段，包含websocket。</li><li>第6行：Sec-WebSocket-Accept字段，详细介绍一下：<blockquote><p>Sec-WebSocket-Accept字段生成步骤：</p><ol><li><p>将Sec-WebSocket-Key与协议中已定义的一个GUID “258EAFA5-E914-47DA-95CA-C5AB0DC85B11”进行拼接。</p></li><li><p>将步骤1中生成的字符串进行SHA1编码。</p></li><li><p>将步骤2中生成的字符串进行Base64编码。</p></li></ol></blockquote></li></ul><blockquote><p>客户端通过验证服务端返回的Sec-WebSocket-Accept的值, 来确定两件事情:</p></blockquote><blockquote><ol><li><p>服务端是否理解WebSocket协议, 如果服务端不理解,那么它就不会返回正确的Sec-WebSocket-Accept，则建立WebSocket连接失败。</p></li><li><p>服务端返回的Response是对于客户端的此次请求的,而不是之前的缓存。主要是防止有些缓存服务器返回缓存的Response.</p></li></ol></blockquote><ul><li>第7行：Sec-WebSocket-Protocol字段，要判断是否之前的Request握手带有此协议，如果没有，则连接失败。</li><li>第8行：扩展协议协商，支持压缩，且LZZ的滑动窗口大小为15。</li></ul><p>至此，握手过程就完成了，此时的TCP连接不会释放。客户端和服务端可以互相通信了。</p><h2 id="HTTP1-1与WebSocket的异同"><a href="#HTTP1-1与WebSocket的异同" class="headerlink" title="HTTP1.1与WebSocket的异同"></a>HTTP1.1与WebSocket的异同</h2><p>最后，作为总结，让我们再来回顾一下HTTP1.1与WebSocket的相同与不同。加深对WebSocket的理解。</p><h1 id="协议层面的异同"><a href="#协议层面的异同" class="headerlink" title="协议层面的异同"></a>协议层面的异同</h1><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><ul><li>都是基于TCP的应用层协议。</li><li>都使用Request/Response模型进行连接的建立。</li><li>在连接的建立过程中对错误的处理方式相同，在这个阶段WebSocket可能返回和HTTP相同的返回码。</li></ul><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><ul><li>HTTP协议基于Request/Response，只能做单向传输，是半双工协议，而WebSocket是全双工协议，类似于Socket通信，双方都可以在任何时刻向另一方发送数据。</li><li>WebSocket使用HTTP来建立连接，但是定义了一系列新的Header域，这些域在HTTP中并不会使用。换言之，二者的请求头不同。</li><li>WebSocket的连接不能通过中间人来转发，它必须是一个直接连接。如果通过代理转发，一个代理要承受如此多的WebSocket连接不释放，就类似于一次DDOS攻击了。</li><li>WebSocket在建立握手连接时，数据是通过HTTP协议传输的，但在建立连接之后，真正的数据传输阶段是不需要HTTP协议参与的。</li><li>WebSocket传输的数据是二进制流，是以帧为单位的，HTTP传输的是明文传输，是字符串传输，WebSocket的数据帧有序。</li></ul><h1 id="HTTP的长连接与WebSocket的持久连接的异同"><a href="#HTTP的长连接与WebSocket的持久连接的异同" class="headerlink" title="HTTP的长连接与WebSocket的持久连接的异同"></a>HTTP的长连接与WebSocket的持久连接的异同</h1><h3 id="HTTP的两种长连接"><a href="#HTTP的两种长连接" class="headerlink" title="HTTP的两种长连接"></a>HTTP的两种长连接</h3><h4 id="一、HTTP1-1的连接默认使用长连接（Persistent-connection）"><a href="#一、HTTP1-1的连接默认使用长连接（Persistent-connection）" class="headerlink" title="一、HTTP1.1的连接默认使用长连接（Persistent connection）"></a>一、HTTP1.1的连接默认使用长连接（Persistent connection）</h4><p>即在一定的期限内保持链接，客户端会需要在短时间内向服务端请求大量的资源，保持TCP连接不断开。客户端与服务器通信，必须要有客户端发起然后服务器返回结果。客户端是主动的，服务器是被动的。在一个TCP连接上可以传输多个Request/Response消息对，所以本质上还是Request/Response消息对，仍然会造成资源的浪费、实时性不强等问题。如果不是持续连接，即短连接，那么每个资源都要建立一个新的连接，HTTP底层使用的是TCP，那么每次都要使用三次握手建立TCP连接，即每一个request对应一个response，将造成极大的资源浪费。</p><h4 id="二、“长轮询”"><a href="#二、“长轮询”" class="headerlink" title="二、“长轮询”"></a>二、“长轮询”</h4><p>即客户端发送一个超时时间很长的Request，服务器保持住这个连接，在有新数据到达时返回Response</p><h3 id="WebSocket的持久连接"><a href="#WebSocket的持久连接" class="headerlink" title="WebSocket的持久连接"></a>WebSocket的持久连接</h3><p>只需建立一次Request/Response消息对，之后都是TCP连接，避免了需要多次建立Request/Response消息对而产生的冗余头部信息。节省了大量流量和服务器资源。因此被广泛应用于线上WEB游戏和线上聊天室的开发。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 基本使用方法</title>
      <link href="/hello-world.html"/>
      <url>/hello-world.html</url>
      
        <content type="html"><![CDATA[<p>欢迎来到 <a href="https://hexo.io/">Hexo</a>! 这是你的第一篇文章。查看 <a href="https://hexo.io/docs/">文档</a>了解更多信息。 如果您在使用Hexo时遇到任何问题，您可以在 <a href="https://hexo.io/docs/troubleshooting.html">疑难解答</a> 中找到答案，也可以在 <a href="https://github.com/hexojs/hexo/issues">GitHub</a>上问我。</p><a id="more"></a> <h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="创建一篇文章"><a href="#创建一篇文章" class="headerlink" title="创建一篇文章"></a>创建一篇文章</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span>  <span class="comment"># 生成文章，会在source/_posts目录下生成一个abc.md文件</span></span><br></pre></td></tr></table></figure><p>更多信息: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="启动本地服务"><a href="#启动本地服务" class="headerlink" title="启动本地服务"></a>启动本地服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>更多信息: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>更多信息: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="部署博客"><a href="#部署博客" class="headerlink" title="部署博客"></a>部署博客</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>更多信息: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
